<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SPM.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://DedZago.github.io/SPM.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SPM.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Package-features"><span>Package features</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DedZago/SPM.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SPM"><a class="docs-heading-anchor" href="#SPM">SPM</a><a id="SPM-1"></a><a class="docs-heading-anchor-permalink" href="#SPM" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/DedZago/SPM.jl">SPM</a>, a package for Statistical Process Monitoring.</p><h2 id="Package-features"><a class="docs-heading-anchor" href="#Package-features">Package features</a><a id="Package-features-1"></a><a class="docs-heading-anchor-permalink" href="#Package-features" title="Permalink"></a></h2><ol><li>Standard control charts<ul><li>Univariate Shewhart, EWMA, AEWMA, and CUSUM control charts;</li><li>MEWMA and MAEWMA control charts;</li></ul></li><li>Control limits<ul><li>Classical one-sided and two-sided control limits;</li><li>Support for multi-chart combinations;</li><li>Dynamic control limits based on bootstrap and permutation methods;</li></ul></li><li>Optimization methods<ul><li>State-of-the-art methods for estimating control limits;</li><li>Optimization of control chart parameters against user-defined out-of-control scenarios;</li></ul></li><li>Extensibility to user-made control statistics<ul><li>Users only need to define the behaviour of the control statistic (<code>struct</code> and sequential update function), everything else is taken care of by the package.</li></ul></li></ol><ul><li><a href="#SPM.AEWMA"><code>SPM.AEWMA</code></a></li><li><a href="#SPM.AMCUSUM"><code>SPM.AMCUSUM</code></a></li><li><a href="#SPM.ARL"><code>SPM.ARL</code></a></li><li><a href="#SPM.BlockBootstrap"><code>SPM.BlockBootstrap</code></a></li><li><a href="#SPM.CUSUM"><code>SPM.CUSUM</code></a></li><li><a href="#SPM.DiagMEWMA"><code>SPM.DiagMEWMA</code></a></li><li><a href="#SPM.EWMA"><code>SPM.EWMA</code></a></li><li><a href="#SPM.LI2012"><code>SPM.LI2012</code></a></li><li><a href="#SPM.LLCUSUM"><code>SPM.LLCUSUM</code></a></li><li><a href="#SPM.LocationScaleStatistic"><code>SPM.LocationScaleStatistic</code></a></li><li><a href="#SPM.MCUSUM"><code>SPM.MCUSUM</code></a></li><li><a href="#SPM.MShewhart"><code>SPM.MShewhart</code></a></li><li><a href="#SPM.OneSidedCurvedLimit"><code>SPM.OneSidedCurvedLimit</code></a></li><li><a href="#SPM.OneSidedFixedLimit"><code>SPM.OneSidedFixedLimit</code></a></li><li><a href="#SPM.Phase2"><code>SPM.Phase2</code></a></li><li><a href="#SPM.Phase2Distribution"><code>SPM.Phase2Distribution</code></a></li><li><a href="#SPM.QRL"><code>SPM.QRL</code></a></li><li><a href="#SPM.Shewhart"><code>SPM.Shewhart</code></a></li><li><a href="#SPM.StationaryBootstrap"><code>SPM.StationaryBootstrap</code></a></li><li><a href="#SPM.TwoSidedCurvedLimit"><code>SPM.TwoSidedCurvedLimit</code></a></li><li><a href="#SPM.TwoSidedFixedLimit"><code>SPM.TwoSidedFixedLimit</code></a></li><li><a href="#SPM.WANG2017"><code>SPM.WANG2017</code></a></li><li><a href="#SPM.apply_chart!-Tuple{SPM.AbstractChart, AbstractVector}"><code>SPM.apply_chart!</code></a></li><li><a href="#SPM.approximateBisectionCL-Tuple{ControlChart}"><code>SPM.approximateBisectionCL</code></a></li><li><a href="#SPM.approximateBisectionCL!-Tuple{ControlChart}"><code>SPM.approximateBisectionCL!</code></a></li><li><a href="#SPM.bisectionCL-Tuple{ControlChart, Any}"><code>SPM.bisectionCL</code></a></li><li><a href="#SPM.bisectionCL!-Tuple{ControlChart, Any}"><code>SPM.bisectionCL!</code></a></li><li><a href="#SPM.calculate_limit_gradient-Tuple{SPM.AbstractChart, Any}"><code>SPM.calculate_limit_gradient</code></a></li><li><a href="#SPM.categorical_to_index-Tuple{AbstractVector, AbstractMatrix}"><code>SPM.categorical_to_index</code></a></li><li><a href="#SPM.categorize_data-Tuple{AbstractVector, Vector{Vector{Float64}}}"><code>SPM.categorize_data</code></a></li><li><a href="#SPM.combinedCL-Tuple{ControlChart}"><code>SPM.combinedCL</code></a></li><li><a href="#SPM.combinedCL!-Tuple{ControlChart}"><code>SPM.combinedCL!</code></a></li><li><a href="#SPM.estimate_loglinear_model_probabilities-Tuple{Any, Any}"><code>SPM.estimate_loglinear_model_probabilities</code></a></li><li><a href="#SPM.estimate_ordinal_model_probabilities-Tuple{Any, Any}"><code>SPM.estimate_ordinal_model_probabilities</code></a></li><li><a href="#SPM.get_design-Tuple{SPM.AbstractChart}"><code>SPM.get_design</code></a></li><li><a href="#SPM.get_limit-Tuple{SPM.AbstractChart}"><code>SPM.get_limit</code></a></li><li><a href="#SPM.get_limit_value-Tuple{SPM.AbstractChart}"><code>SPM.get_limit_value</code></a></li><li><a href="#SPM.get_maxrl-Tuple{SPM.AbstractChart}"><code>SPM.get_maxrl</code></a></li><li><a href="#SPM.get_nominal-Tuple{SPM.AbstractChart}"><code>SPM.get_nominal</code></a></li><li><a href="#SPM.get_nominal_value-Tuple{SPM.AbstractChart}"><code>SPM.get_nominal_value</code></a></li><li><a href="#SPM.get_phase2-Tuple{SPM.AbstractChart}"><code>SPM.get_phase2</code></a></li><li><a href="#SPM.get_statistic-Tuple{SPM.AbstractChart}"><code>SPM.get_statistic</code></a></li><li><a href="#SPM.get_t-Tuple{SPM.AbstractChart}"><code>SPM.get_t</code></a></li><li><a href="#SPM.get_value-Tuple{SPM.AbstractStatistic}"><code>SPM.get_value</code></a></li><li><a href="#SPM.get_value-Tuple{SPM.AbstractChart}"><code>SPM.get_value</code></a></li><li><a href="#SPM.is_IC-Tuple{SPM.AbstractChart}"><code>SPM.is_IC</code></a></li><li><a href="#SPM.is_IC_vec-Tuple{MultipleControlChart}"><code>SPM.is_IC_vec</code></a></li><li><a href="#SPM.kronecker_matrix-Tuple{AbstractVector}"><code>SPM.kronecker_matrix</code></a></li><li><a href="#SPM.new_data-Tuple{Phase2}"><code>SPM.new_data</code></a></li><li><a href="#SPM.new_data-Tuple{SPM.AbstractChart}"><code>SPM.new_data</code></a></li><li><a href="#SPM.new_data!-Tuple{SPM.AbstractChart}"><code>SPM.new_data!</code></a></li><li><a href="#SPM.optimize_design"><code>SPM.optimize_design</code></a></li><li><a href="#SPM.optimize_design!"><code>SPM.optimize_design!</code></a></li><li><a href="#SPM.optimize_grid-Tuple{ControlChart, Function, OptSettings}"><code>SPM.optimize_grid</code></a></li><li><a href="#SPM.optimize_limit"><code>SPM.optimize_limit</code></a></li><li><a href="#SPM.optimize_limit!"><code>SPM.optimize_limit!</code></a></li><li><a href="#SPM.optimize_nlopt-Tuple{ControlChart, Function, OptSettings}"><code>SPM.optimize_nlopt</code></a></li><li><a href="#SPM.quantile_range-Tuple{Any, Any, Any}"><code>SPM.quantile_range</code></a></li><li><a href="#SPM.run_path_sim-Tuple{SPM.AbstractChart}"><code>SPM.run_path_sim</code></a></li><li><a href="#SPM.run_sim-Tuple{SPM.AbstractChart}"><code>SPM.run_sim</code></a></li><li><a href="#SPM.run_sim-Tuple{SPM.AbstractChart, SPM.AbstractPhase2}"><code>SPM.run_sim</code></a></li><li><a href="#SPM.run_sim_oc-Tuple{SPM.AbstractChart}"><code>SPM.run_sim_oc</code></a></li><li><a href="#SPM.run_sim_sa-Tuple{SPM.AbstractChart}"><code>SPM.run_sim_sa</code></a></li><li><a href="#SPM.saCL-Tuple{ControlChart}"><code>SPM.saCL</code></a></li><li><a href="#SPM.saCL!-Tuple{ControlChart}"><code>SPM.saCL!</code></a></li><li><a href="#SPM.set_design!-Tuple{SPM.AbstractChart, Any}"><code>SPM.set_design!</code></a></li><li><a href="#SPM.set_limit!-Tuple{SPM.AbstractChart, SPM.AbstractLimit}"><code>SPM.set_limit!</code></a></li><li><a href="#SPM.set_nominal!-Union{Tuple{C}, Tuple{N}, Tuple{C, N}} where {N&lt;:SPM.NominalProperties, C&lt;:SPM.AbstractChart}"><code>SPM.set_nominal!</code></a></li><li><a href="#SPM.set_phase2!-Union{Tuple{C}, Tuple{PH2}, Tuple{C, PH2}} where {PH2&lt;:SPM.AbstractPhase2, C&lt;:SPM.AbstractChart}"><code>SPM.set_phase2!</code></a></li><li><a href="#SPM.set_statistic!-Union{Tuple{C}, Tuple{STAT}, Tuple{C, STAT}} where {STAT&lt;:SPM.AbstractStatistic, C&lt;:SPM.AbstractChart}"><code>SPM.set_statistic!</code></a></li><li><a href="#SPM.set_t!-Union{Tuple{C}, Tuple{C, Int64}} where C&lt;:SPM.AbstractChart"><code>SPM.set_t!</code></a></li><li><a href="#SPM.set_value!-Tuple{SPM.AbstractStatistic, Any}"><code>SPM.set_value!</code></a></li><li><a href="#SPM.set_value!-Union{Tuple{C}, Tuple{C, Any}} where C&lt;:SPM.AbstractChart"><code>SPM.set_value!</code></a></li><li><a href="#SPM.shallow_copy_sim-Tuple{ControlChart}"><code>SPM.shallow_copy_sim</code></a></li><li><a href="#SPM.update_chart-Tuple{SPM.AbstractChart, Any}"><code>SPM.update_chart</code></a></li><li><a href="#SPM.update_chart!-Tuple{SPM.AbstractChart, Any}"><code>SPM.update_chart!</code></a></li><li><a href="#SPM.update_limit!-Union{Tuple{SPM.AbstractChart{S, L, N, P1}}, Tuple{P1}, Tuple{N}, Tuple{L}, Tuple{S}} where {S, L&lt;:SPM.BootstrapLimit, N, P1}"><code>SPM.update_limit!</code></a></li><li><a href="#SPM.update_statistic!-Tuple{SPM.AbstractStatistic, Any}"><code>SPM.update_statistic!</code></a></li><li><a href="#SPM.update_value!-Tuple{SPM.BootstrapLimit, ARL}"><code>SPM.update_value!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SPM.apply_chart!-Tuple{SPM.AbstractChart, AbstractVector}" href="#SPM.apply_chart!-Tuple{SPM.AbstractChart, AbstractVector}"><code>SPM.apply_chart!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_chart(CH::AbstractChart, x::AbstractVecOrMat)
apply_chart!(CH::AbstractChart, x::AbstractVector)
apply_chart!(CH::AbstractChart, x::AbstractMatrix)</code></pre><p>Apply a control chart to a data vector or data matrix <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/retrospective.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.approximateBisectionCL!-Tuple{ControlChart}" href="#SPM.approximateBisectionCL!-Tuple{ControlChart}"><code>SPM.approximateBisectionCL!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approximateBisectionCL!(CH::ControlChart[; rlsim::Function, settings::OptSettings])</code></pre><p>Computes the control limit to satisfy the nominal properties of a control chart, using the bisection algorithm on bootstrapped paths (see for instance Qiu, 2013).</p><p><strong>Inputs</strong></p><ul><li><code>CH</code> - A control chart.</li><li><code>rlsim</code> - A function that generates a path of the control chart statistic with signature <code>rlsim(CH; maxiter)</code>. If left unspecified, defaults to <code>run_path_sim</code>. See the help for <code>run_path_sim</code> for more information about the signature of the function.</li><li><code>settings</code> - An <code>OptSettings</code> objects which contains variables that control the behaviour of the algorithm. See the <code>Accepted settings</code> section below for information about the settings that control the behaviour of the algorithm. For more information about the specifics of each keyword argument, see for instance Qiu (2013).</li></ul><p><strong>Accepted settings:</strong></p><ul><li><code>maxiter</code> - The maximum number of bisection iterations.</li><li><code>nsims</code> - The number of run lengths used to estimate the target nominal property.</li><li><code>maxrl</code> - The maximum run length after which the run length is truncated, to avoid excessive computations.</li><li><code>x_tol</code> - Absolute tolerance for the algorithm, which is ended if   <span>$h^{(k+1)} - h^{(k)} &lt; x_{\text{tol}}$</span></li><li><code>f_tol</code> - Absolute tolerance for the algorithm, which is ended if   <span>$\text{target}(h^{(k+1)}) - \text{target}(h^{(k)}) &lt; f_{\text{tol}}$</span></li></ul><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the estimated control limit <code>h</code>, the total number of iterations <code>iter</code>, and information <code>status</code> about the convergence of the algorithm.</li></ul><p><strong>References</strong></p><ul><li>Qiu, P. (2013). Introduction to Statistical Process Control. CRC Press.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/double-bootstrap.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.approximateBisectionCL-Tuple{ControlChart}" href="#SPM.approximateBisectionCL-Tuple{ControlChart}"><code>SPM.approximateBisectionCL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approximateBisectionCL(CH::ControlChart; kw...)</code></pre><p>Applies the bisection algorithm on simulated run length paths to find the control limit of a control chart without modifying the control chart object <code>CH</code>. See the documentation of <code>approximateBisectionCL!</code> for more information about the algorithm and keyword arguments.</p><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the estimated control limit <code>h</code>, the total number of iterations <code>iter</code>, and information <code>status</code> about the convergence of the algorithm.</li></ul><p><strong>References</strong></p><ul><li>Qiu, P. (2013). Introduction to Statistical Process Control. CRC Press.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/double-bootstrap.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.bisectionCL!-Tuple{ControlChart, Any}" href="#SPM.bisectionCL!-Tuple{ControlChart, Any}"><code>SPM.bisectionCL!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bisectionCL!(CH::ControlChart[; rlsim::Function, settings::OptSettings])</code></pre><p>Computes the control limit to satisfy the nominal properties of a control chart, using the bisection algorithm (see for instance Qiu, 2013)</p><p><strong>Inputs</strong></p><ul><li><code>CH</code> - A control chart.</li><li><code>hmax</code> - The maximum value for the control limit.</li></ul><p><strong>Accepted settings:</strong></p><ul><li><code>rlsim</code> - A function that generates a run length for the control chart with signature <code>rlsim(CH; maxiter)</code>. If left unspecified, defaults to <code>run_sim</code>. See the help for <code>run_sim</code> for more information about the signature of the function.</li><li><code>nsims</code> - The number of run lengths used to estimate the target nominal property (default: 10000).</li><li><code>hmin</code> - The minimum value of the control limit, (default: <code>sqrt(eps())</code>).</li><li><code>maxiter</code> - The maximum number of bisection iterations (default: 30).</li><li><code>maxrl</code> - The value at which to maxrlate the run length, to avoid excessive computations (default: Inf, i.e. no maxrlation).</li><li><code>x_tol</code> - Absolute tolerance for the algorithm, which is terminated if   <span>$h^{(k+1)} - h^{(k)} &lt; x_{\text{tol}}$</span>   (default: 1e-06)</li><li><code>f_tol</code> - Absolute tolerance for the algorithm, which is terminated if   <span>$\text{target}(h^{(k+1)}) - \text{target}(h^{(k)}) &lt; f_{\text{tol}}$</span>   (default: 1.0)</li><li><code>verbose</code> - Whether to print information to the user about the state of the optimization (default: false).</li><li><code>parallel::Bool</code> - Whether the algorithm should be run in parallel, using available threads (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the estimated control limit <code>h</code>, the total number of iterations <code>iter</code>, and information <code>status</code> about the convergence of the algorithm.</li></ul><p><strong>References</strong></p><ul><li>Qiu, P. (2013). Introduction to Statistical Process Control. CRC Press.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/bisectioncl.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.bisectionCL-Tuple{ControlChart, Any}" href="#SPM.bisectionCL-Tuple{ControlChart, Any}"><code>SPM.bisectionCL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bisectionCL(CH::ControlChart; kw...)</code></pre><p>Applies the bisection algorithm to find the control limit of a control chart without modifying the control chart object <code>CH</code>. See the documentation of <code>bisectionCL!</code> for more information about the algorithm and keyword arguments.</p><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the estimated control limit <code>h</code>, the total number of iterations <code>iter</code>, and information <code>status</code> about the convergence of the algorithm.</li></ul><p><strong>References</strong></p><ul><li>Qiu, P. (2013). Introduction to Statistical Process Control. CRC Press.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/bisectioncl.jl#L95-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.calculate_limit_gradient-Tuple{SPM.AbstractChart, Any}" href="#SPM.calculate_limit_gradient-Tuple{SPM.AbstractChart, Any}"><code>SPM.calculate_limit_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_limit_gradient(CH::AbstractChart, rl::Real)
calculate_limit_gradient(nominal::ARL, rl)
calculate_limit_gradient(nominal::QRL, rl)</code></pre><p>Calculate the gradient for the optimization of the control limit.</p><p>If the control chart <code>nominal</code> attribute is of type <code>ARL</code>, then the gradient is calculated according to Equation (9) of Capizzi and Masarotto (2016).</p><p>If the control chart <code>nominal</code> attribute is of type <code>QRL</code>, then the gradient is calculated using the recursion on page 280 of Capizzi and Masarotto (2009)</p><p><strong>References</strong></p><p>Capizzi, G., &amp; Masarotto, G. (2016). &quot;Efficient Control Chart Calibration by Simulated Stochastic Approximation&quot;. IIE Transactions 48 (1). https://doi.org/10.1080/0740817X.2015.1055392.</p><p>Capizzi, G. &amp; Masarotto, G. (2009) Bootstrap-based design of residual control charts, IIE Transactions, 41:4, 275-286, DOI: https://doi.org/10.1080/07408170802120059 </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/sacl.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.categorical_to_index-Tuple{AbstractVector, AbstractMatrix}" href="#SPM.categorical_to_index-Tuple{AbstractVector, AbstractMatrix}"><code>SPM.categorical_to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">categorical_to_index(g::AbstractVector, table::AbstractMatrix)</code></pre><p>Converts a categorized variable <code>g</code> to its corresponding index in a table.</p><p><strong>Arguments</strong></p><ul><li><code>g::AbstractVector</code>: The categorical variable to convert.</li><li><code>table::AbstractMatrix</code>: The table containing all the possible categories.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: The index of the category in the table.</li></ul><p><strong>Raises</strong></p><ul><li><code>ErrorException</code> if the index is not found</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">x = randn(500, 3)
df, table, qtls = create_table(x, [2 for _ in eachcol(x)])
xnew = randn(3)
g = categorize_data(xnew, qtls)
idx = categorical_to_index(g, table)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/LLCUSUM.jl#L88-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.categorize_data-Tuple{AbstractVector, Vector{Vector{Float64}}}" href="#SPM.categorize_data-Tuple{AbstractVector, Vector{Vector{Float64}}}"><code>SPM.categorize_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">categorize_data(x::AbstractVector, qtls::Vector{Vector{Float64}})
categorize_data(x::AbstractMatrix, qtls::Vector{Vector{Float64}})</code></pre><p>Categorize continuous data using the medians of the continuous variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/categorization.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.combinedCL!-Tuple{ControlChart}" href="#SPM.combinedCL!-Tuple{ControlChart}"><code>SPM.combinedCL!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combinedCL!(CH::ControlChart[; rlsim::Function, settings::OptSettings])</code></pre><p>Computes the control limit to satisfy the nominal properties of a control chart, using the bisection algorithm (see for instance Qiu, 2013). The control limit upper bound <code>hmax</code> for the bisection algorithm is found using the stochastic approximation algorithm of Capizzi and Masarotto (2016)</p><p><strong>Inputs</strong></p><ul><li><code>CH</code> - A control chart.</li></ul><p><strong>Accepted settings</strong></p><ul><li><code>inflate::Real</code> - An inflation constant for the starting control limit value so that, on average, the first iteration will move the control limit to lower values. This usually saves computational time (default: 1.05).</li><li><code>parallel::Bool</code> - Whether the algorithm should be run in parallel, using available threads (default: false)</li></ul><p><strong>Bisection algorithm</strong></p><ul><li><code>rlsim</code> - A function that generates a run length for the control chart with signature <code>rlsim(CH; maxiter)</code>. If left unspecified, defaults to <code>run_sim</code>. See the help for <code>run_sim</code> for more information about the signature of the function.</li><li><code>nsims</code> - The number of run lengths used to estimate the target nominal property (default: 10000).</li><li><code>hmin</code> - The minimum value of the control limit, (default: <code>sqrt(eps())</code>).</li><li><code>maxiter</code> - The maximum number of bisection iterations (default: 30).</li><li><code>maxrl</code> - The value at which to maxrlate the run length, to avoid excessive computations (default: Inf, i.e. no maxrlation).</li><li><code>x_tol</code> - Absolute tolerance for the algorithm, which is terminated if   <span>$h^{(k+1)} - h^{(k)} &lt; x_{\text{tol}}$</span>   (default: 1e-06)</li><li><code>f_tol</code> - Absolute tolerance for the algorithm, which is terminated if   <span>$\text{target}(h^{(k+1)}) - \text{target}(h^{(k)}) &lt; f_{\text{tol}}$</span>   (default: 1.0)</li></ul><p><strong>SA algorithm</strong></p><ul><li><code>Nfixed</code> - The number of iterations for the gain estimation stage (default: 200).</li><li><code>Afixed</code> - The fixed gain during the gain estimation stage (default: 0.1).</li><li><code>Amin</code> - The minimum allowed value of gain (default: 0.1).</li><li><code>Amax</code> - The maximum allowed value of gain (default: 100).</li><li><code>deltaSA</code> - The shift in control limit used during the gain estimation stage (default: 0.1).</li><li><code>q</code> - The power that controls the denominator in the Robbins-Monro algorithm (default: 0.55).</li><li><code>gamma</code> - The precision parameter for the stopping criterion of the algorithm (default: 0.05).</li><li><code>Nmin</code> - The minimum number of iterations required for the algorithm to end (default: 200).</li><li><code>z</code> - The quantile of the <code>Normal(0,1)</code> that controls the probability of the stopping criterion being satisfied (default: 3.0).</li><li><code>Cmrl</code> - The inflation factor for the maximum number of iterations the run length may run for (default: 10.0).</li><li><code>maxiter_sa</code> - Maximum number of iterations before the algorithm is forcibly ended (default: 200).</li><li><code>verbose</code> - Whether to print information to the user about the state of the optimization (default: false).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the estimated control limit <code>h</code>, the total number of iterations <code>iter</code>, and information <code>status</code> about the convergence of the algorithm.</li></ul><p><strong>References</strong></p><ul><li>Qiu, P. (2013). Introduction to Statistical Process Control. CRC Press.</li><li>Capizzi, G., &amp; Masarotto, G. (2016). Efficient control chart calibration by simulated stochastic approximation. IIE Transactions, 48(1), 57-65. https://doi.org/10.1080/0740817X.2015.1055392</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/bisectioncl.jl#L129-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.combinedCL-Tuple{ControlChart}" href="#SPM.combinedCL-Tuple{ControlChart}"><code>SPM.combinedCL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combinedCL(CH::ControlChart; kw...)</code></pre><p>Applies the bisection algorithm to find the control limit of a control chart without modifying the control chart object <code>CH</code>. The control limit upper bound <code>hmax</code> for the bisection algorithm is found using the stochastic approximation algorithm of Capizzi and Masarotto (2016). See the documentation of <code>combinedCL!</code> for more information about the algorithm and keyword arguments.</p><p><strong>Keyword arguments:</strong></p><ul><li>See the documentation of <code>combinedCL!</code> for a list of keyword arguments.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the estimated control limit <code>h</code>, the total number of iterations <code>iter</code>, and information <code>status</code> about the convergence of the algorithm.</li></ul><p><strong>References</strong></p><ul><li>Qiu, P. (2013). Introduction to Statistical Process Control. CRC Press.</li><li>Capizzi, G., &amp; Masarotto, G. (2016). Efficient control chart calibration by simulated stochastic approximation. IIE Transactions, 48(1), 57-65. https://doi.org/10.1080/0740817X.2015.1055392</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/bisectioncl.jl#L183-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.estimate_loglinear_model_probabilities-Tuple{Any, Any}" href="#SPM.estimate_loglinear_model_probabilities-Tuple{Any, Any}"><code>SPM.estimate_loglinear_model_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimate_ordinal_model_probabilities(df, table)</code></pre><p>Estimates the probabilities of an ordinal loglinear model based on the observed cell counts.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: The data frame containing the predictor variables.</li><li><code>table::AbstractMatrix</code>: The matrix of predictor values for which probabilities are to be estimated.</li></ul><p><strong>Returns</strong></p><ul><li><code>prob::Vector{Float64}</code>: A vector of estimated probabilities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/LLCUSUM.jl#L49-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.estimate_ordinal_model_probabilities-Tuple{Any, Any}" href="#SPM.estimate_ordinal_model_probabilities-Tuple{Any, Any}"><code>SPM.estimate_ordinal_model_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimate_ordinal_model_probabilities(df, table)</code></pre><p>Estimates the probabilities of an ordinal loglinear model based on the observed cell counts.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: The data frame containing the predictor variables.</li><li><code>table::AbstractMatrix</code>: The matrix of predictor values for which probabilities are to be estimated.</li></ul><p><strong>Returns</strong></p><ul><li><code>prob::Vector{Float64}</code>: A vector of estimated probabilities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/WANG2017.jl#L52-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_design-Tuple{SPM.AbstractChart}" href="#SPM.get_design-Tuple{SPM.AbstractChart}"><code>SPM.get_design</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_design(CH::AbstractChart)</code></pre><p>Get the designs of the control chart statistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_limit-Tuple{SPM.AbstractChart}" href="#SPM.get_limit-Tuple{SPM.AbstractChart}"><code>SPM.get_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_limit(CH::AbstractChart)</code></pre><p>Get the control limit of a control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_limit_value-Tuple{SPM.AbstractChart}" href="#SPM.get_limit_value-Tuple{SPM.AbstractChart}"><code>SPM.get_limit_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_limit_value(CH::AbstractChart)</code></pre><p>Get the control limit value of a control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_maxrl-Tuple{SPM.AbstractChart}" href="#SPM.get_maxrl-Tuple{SPM.AbstractChart}"><code>SPM.get_maxrl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_maxrl(CH::AbstractChart)</code></pre><p>Get the maximum run length of the control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_nominal-Tuple{SPM.AbstractChart}" href="#SPM.get_nominal-Tuple{SPM.AbstractChart}"><code>SPM.get_nominal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_nominal(CH::AbstractChart)</code></pre><p>Get the nominal properties of a control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_nominal_value-Tuple{SPM.AbstractChart}" href="#SPM.get_nominal_value-Tuple{SPM.AbstractChart}"><code>SPM.get_nominal_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_nominal(CH::AbstractChart)</code></pre><p>Get the nominal value of a control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_phase2-Tuple{SPM.AbstractChart}" href="#SPM.get_phase2-Tuple{SPM.AbstractChart}"><code>SPM.get_phase2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_phase2(CH::AbstractChart)</code></pre><p>Get the phase 2 information of a control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_statistic-Tuple{SPM.AbstractChart}" href="#SPM.get_statistic-Tuple{SPM.AbstractChart}"><code>SPM.get_statistic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_statistic(CH::AbstractChart)</code></pre><p>Get the statistic of a control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_t-Tuple{SPM.AbstractChart}" href="#SPM.get_t-Tuple{SPM.AbstractChart}"><code>SPM.get_t</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_t(CH::AbstractChart)</code></pre><p>Get the current time point of a control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_value-Tuple{SPM.AbstractChart}" href="#SPM.get_value-Tuple{SPM.AbstractChart}"><code>SPM.get_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_value(CH::AbstractChart)</code></pre><p>Get the current value of the control chart statistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.get_value-Tuple{SPM.AbstractStatistic}" href="#SPM.get_value-Tuple{SPM.AbstractStatistic}"><code>SPM.get_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_value(stat::AbstractStatistic)</code></pre><p>Get the current value of a statistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/stats-interface.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.is_IC-Tuple{SPM.AbstractChart}" href="#SPM.is_IC-Tuple{SPM.AbstractChart}"><code>SPM.is_IC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_IC(CH::AbstractChart)
is_OC(CH::AbstractChart)</code></pre><p>Check whether the control chart is in control or out of control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.is_IC_vec-Tuple{MultipleControlChart}" href="#SPM.is_IC_vec-Tuple{MultipleControlChart}"><code>SPM.is_IC_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_IC_vec(CH::MultipleControlChart)
is_OC_vec(CH::MultipleControlChart)</code></pre><p>Check whether each individual control chart that makes up a multiple control chart is in control or out of control.</p><p><strong>Returns</strong></p><p>A vector of Bool, whose length is the number of individual statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L178-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.kronecker_matrix-Tuple{AbstractVector}" href="#SPM.kronecker_matrix-Tuple{AbstractVector}"><code>SPM.kronecker_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kronecker_matrix(qtls::AbstractVector)</code></pre><p>Compute the matrix given by the Kronecker vectors according to Equation (6) of Wang et Al. (2017). This matrix is used to compute the approximate GLRT statistic to test the null hypothesis that the main effects and the second order interactions of a log-linear model are stable.</p><p><strong>References</strong></p><p>Wang, J., Li, J., &amp; Su, Q. (2017). Multivariate Ordinal Categorical Process Control Based on Log-Linear Modeling. Journal of Quality Technology, 49(2), 108-122. https://doi.org/10.1080/00224065.2017.11917983</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/categorization.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.new_data!-Tuple{SPM.AbstractChart}" href="#SPM.new_data!-Tuple{SPM.AbstractChart}"><code>SPM.new_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_data(CH::AbstractChart)</code></pre><p>Simulate a new observation for the control chart from the phase 2 data, eventually modifying the underlying phase 2 object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.new_data-Tuple{Phase2}" href="#SPM.new_data-Tuple{Phase2}"><code>SPM.new_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_data(PH2::Phase2{S,T})
new_data(PH2::Phase2{S,AbstractVector})
new_data(PH2::Phase2{S,AbstractMatrix})</code></pre><p>Generates a new observation based on the observed Phase I (in-control) data. If it is not overloaded, then it defaults to generating data using a nonparametric bootstrap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/phase2/phase2-interface.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.new_data-Tuple{SPM.AbstractChart}" href="#SPM.new_data-Tuple{SPM.AbstractChart}"><code>SPM.new_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_data(CH::AbstractChart)</code></pre><p>Simulate a new observation for the control chart from the phase 2 data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.optimize_design" href="#SPM.optimize_design"><code>SPM.optimize_design</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_design(CH::ControlChart, rlsim_oc::Function, settings::OptSettings=OptSettings(CH); optimizer::Symbol = :LN_BOBYQA, solver::Symbol = :SACL, nsims_opt::Int = 1000, kw...)</code></pre><p>Optimizes the design of a control chart using a specified optimization algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>CH::ControlChart</code>: The control chart object to optimize.</li><li><code>rlsim_oc::Function</code>: A function that simulates the out-of-control state of the control chart.</li><li><code>settings::OptSettings</code>: The optimization settings that control the optimization routine (default: <code>OptSettings(CH)</code>).</li><li><code>optimizer::Symbol</code>: The optimization algorithm to use (default: <code>:LN_BOBYQA</code>).</li><li><code>solver::Symbol</code>: The root-finding algorithm to use for control limit estimation (default: <code>:Bootstrap</code>).</li><li><code>hmax::Float64</code>: The maximum value of the control limit, used only for the bisection algorithm (default: 20.0)</li><li><code>kw...</code>: Additional keyword arguments to pass to the solver algorithm.</li></ul><p><strong>Returns</strong></p><p>The optimized design parameters of the control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/interface.jl#L112-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.optimize_design!" href="#SPM.optimize_design!"><code>SPM.optimize_design!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_design!(CH::ControlChart, rlsim_oc::Function, settings::OptSettings=OptSettings(CH); optimizer = :LN_BOBYQA, solver = :Bootstrap, hmax::Float64 = 20.0, kw...)</code></pre><p>Optimizes the design of a control chart <code>CH</code> using a specified optimization algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>CH::ControlChart</code>: The control chart object to optimize.</li><li><code>rlsim_oc::Function</code>: A function that simulates the out-of-control state of the control chart.</li><li><code>settings::OptSettings</code>: The optimization settings that control the optimization routine (default: <code>OptSettings(CH)</code>).</li><li><code>optimizer::Symbol</code>: The optimization algorithm to use (default: <code>:LN_BOBYQA</code>).</li><li><code>solver::Symbol</code>: The root-finding algorithm to use for control limit estimation (default: <code>:Bootstrap</code>).</li><li><code>hmax::Float64</code>: The maximum value of the control limit, used only for the bisection algorithm (default: 20.0)</li><li><code>kw...</code>: Additional keyword arguments to pass to the solver algorithm.</li></ul><p><strong>Returns</strong></p><p>The optimized design parameters of the control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/interface.jl#L64-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.optimize_grid-Tuple{ControlChart, Function, OptSettings}" href="#SPM.optimize_grid-Tuple{ControlChart, Function, OptSettings}"><code>SPM.optimize_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_grid(CH::ControlChart, rlconstr::Function, settings::OptSettings)</code></pre><p>Optimizes a control chart by finding the best set of parameters using a grid search.</p><p><strong>Args</strong></p><ul><li>CH: the control chart to optimize.</li><li>rlconstr: the function that evaluates the OC performance of the control chart.</li><li>settings: the optimization settings.</li></ul><p><strong>Returns</strong></p><ul><li>par_current (Vector{Float64}): the optimal set of parameters found by the optimization algorithm.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/design/grid-search.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.optimize_limit" href="#SPM.optimize_limit"><code>SPM.optimize_limit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_limit(CH::ControlChart, solver::Symbol = :Bootstrap; kw...)</code></pre><p>Optimizes the control limit of a ControlChart object, without modifying the original ControlChart object.</p><p><strong>Args</strong></p><ul><li><code>CH::ControlChart</code>: The ControlChart object to optimize.</li><li><code>solver::Symbol</code>: The solver algorithm to use (default: <code>:Bootstrap</code>).</li><li><code>hmax::Float64</code>: The maximum value of the control limit, used only for the bisection algorithm (default: 20.0)</li><li><code>kw...</code>: Additional keyword arguments to pass to the algorithm.</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">The optimized control limit value.</code></pre><p><strong>Raises</strong></p><pre><code class="nohighlight hljs">ValueError: If the optimization method specified in settings is unknown.</code></pre><p><strong>Example</strong></p><pre><code class="nohighlight hljs">optimize_limit(my_chart, settings=OptSettings(ic_solver=:SA))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/interface.jl#L37-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.optimize_limit!" href="#SPM.optimize_limit!"><code>SPM.optimize_limit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_limit(CH::ControlChart, solver = :Bootstrap; hmax = 20.0, kw...)</code></pre><p>Optimizes the control limit of a ControlChart object.</p><p><strong>Args</strong></p><ul><li><code>CH::ControlChart</code>: The ControlChart object to optimize.</li><li><code>solver::Symbol</code>: The solver algorithm to use (default: <code>:Bootstrap</code>).</li><li><code>hmax::Float64</code>: The maximum value of the control limit, used only for the bisection algorithm (default: 20.0)</li><li><code>kw...</code>: Additional keyword arguments to pass to the algorithm.</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">The optimized control limit value.</code></pre><p><strong>Raises</strong></p><pre><code class="nohighlight hljs">ValueError: If the optimization method specified in settings is unknown.</code></pre><p><strong>Example</strong></p><pre><code class="nohighlight hljs">optimize_limit!(my_chart, settings=OptSettings(ic_solver=:SA))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/interface.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.optimize_nlopt-Tuple{ControlChart, Function, OptSettings}" href="#SPM.optimize_nlopt-Tuple{ControlChart, Function, OptSettings}"><code>SPM.optimize_nlopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_nlopt(CH::ControlChart, rlconstr::Function, settings::OptSettings)</code></pre><p>Optimizes the Control Chart design parameter using the NLOpt library.</p><p><strong>Args</strong></p><ul><li><code>CH</code>: The ControlChart object to be optimized.</li><li><code>rlconstr</code>: The objective function to be minimized.</li><li><code>settings</code>: The settings for the optimization process. Includes:<ul><li><code>minpar</code>: The lower bounds for the parameters.</li><li><code>maxpar</code>: The upper bounds for the parameters.</li><li><code>x_tol</code>: The relative tolerance for convergence.</li><li><code>maxiter</code>: The maximum number of iterations.</li><li><code>optimizer</code>: The optimization method to be used.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>minx::Vector{Float64}</code>: The set of optimal parameters for the Control Chart.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/design/nlopt.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.quantile_range-Tuple{Any, Any, Any}" href="#SPM.quantile_range-Tuple{Any, Any, Any}"><code>SPM.quantile_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quantile_range(lower, upper, m)</code></pre><p>Get the set of quantiles needed to divide the data in m classes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/categorization.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.run_path_sim-Tuple{SPM.AbstractChart}" href="#SPM.run_path_sim-Tuple{SPM.AbstractChart}"><code>SPM.run_path_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_path_sim(CH::AbstractChart; maxiter)
run_path_sim(CH::MultipleControlChart; maxiter)</code></pre><p>Simulates a run length path for the control chart <code>CH</code> by sampling new data from its Phase II object.</p><p><strong>Inputs</strong></p><ul><li><code>CH::AbstractChart</code> - A control chart.</li><li><code>maxiter::Real</code> - The maximum value of the run length. Defaults to <code>min(maxrl(CH), 10*get_nominal_value(CH))</code></li></ul><p><strong>Returns</strong></p><ul><li>A vector containing values of the control chart.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/simulate.jl#L185-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.run_sim-Tuple{SPM.AbstractChart, SPM.AbstractPhase2}" href="#SPM.run_sim-Tuple{SPM.AbstractChart, SPM.AbstractPhase2}"><code>SPM.run_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_sim(CH::AbstractChart, DGP::AbstractPhase2)</code></pre><p>Simulates a run length for the control chart <code>CH</code> by sampling new data from the provided data-generating process <code>DGP</code>.</p><p><strong>Inputs</strong></p><ul><li><code>CH</code> - A control chart.</li><li><code>DGP</code> - An AbstractPhase2 object.</li></ul><p><strong>Returns</strong></p><ul><li>An <code>Int</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/simulate.jl#L25-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.run_sim-Tuple{SPM.AbstractChart}" href="#SPM.run_sim-Tuple{SPM.AbstractChart}"><code>SPM.run_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_sim(CH::AbstractChart)</code></pre><p>Simulates a run length for the control chart <code>CH</code> by sampling new data from its Phase II object.</p><p><strong>Inputs</strong></p><ul><li><code>CH</code> - A control chart.</li></ul><p><strong>Returns</strong></p><ul><li>An <code>Int</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/simulate.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.run_sim_oc-Tuple{SPM.AbstractChart}" href="#SPM.run_sim_oc-Tuple{SPM.AbstractChart}"><code>SPM.run_sim_oc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_sim_oc(CH::AbstractChart; shift = 0.0)</code></pre><p>Simulates a run length under location shift for the control chart <code>CH</code> by sampling new data from its Phase II object.</p><p><strong>Inputs</strong></p><ul><li><code>CH</code> - A control chart.</li><li><code>shift</code> - A location shift.</li></ul><p><strong>Returns</strong></p><ul><li>An <code>Int</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/simulate.jl#L159-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.run_sim_sa-Tuple{SPM.AbstractChart}" href="#SPM.run_sim_sa-Tuple{SPM.AbstractChart}"><code>SPM.run_sim_sa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_sim_sa(CH::AbstractChart, maxiter::Real, delta::Real)</code></pre><p>Simulates a run length for the control chart <code>CH</code> by sampling new data from the Phase II object, to be used by the stochastic approximation algorithm implemented in the <code>saCL!</code> function.</p><p><strong>Inputs</strong></p><ul><li><code>CH</code> - A control chart.</li><li><code>maxiter</code> - The maximum value of the run length.</li><li><code>delta</code> - A value controlling how much the control limit must be shifted for the gain estimation during the first stage.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the simulated run length, <code>rl</code>, the simulated run length with control limit shifted by <code>delta</code>, <code>rlPlus</code>, and the simulated run length with control limit shifted by <code>-delta</code>, <code>rlMinus</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/simulate.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.saCL!-Tuple{ControlChart}" href="#SPM.saCL!-Tuple{ControlChart}"><code>SPM.saCL!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saCL!(CH::ControlChart[; rlsim::Function, settings::OptSettings])</code></pre><p>Computes the control limit to satisfy the nominal properties of a control chart, using the stochastic approximation algorithm described in Capizzi and Masarotto (2016).</p><p><strong>Inputs</strong></p><ul><li><code>CH</code> - A control chart.</li><li><code>rlsim</code> - A function that generates new data with signature <code>rlsim(CH; maxiter, delta)</code>. If left unspecified, defaults to <code>run_sim_sa</code>. See the help for <code>run_sim_sa</code> for more information about the signature of the function.</li><li><code>settings</code> - An <code>OptSettings</code> objects which contains variables that control the behaviour of the algorithm. See the <code>Accepted settings</code> section below for information about the settings that control the behaviour of the algorithm. For more information about the specifics of each keyword argument, see Capizzi and Masarotto (2016).</li></ul><p><strong>Settings</strong></p><p>The following settings control the behaviour of the algorithm: </p><ul><li><code>Nfixed</code> - The number of iterations for the gain estimation stage (default: 500).</li><li><code>Afixed</code> - The fixed gain during the gain estimation stage (default: 0.1).</li><li><code>Amin</code> - The minimum allowed value of gain (default: 0.1).</li><li><code>Amax</code> - The maximum allowed value of gain (default: 100.0).</li><li><code>delta_sa</code> - The shift in control limit used during the gain estimation stage (default: 0.1).</li><li><code>q</code> - The power that controls the denominator in the Robbins-Monro algorithm (default: 0.55).</li><li><code>gamma</code> - The precision parameter for the stopping criterion of the algorithm (default: 0.02).</li><li><code>Nmin</code> - The minimum number of iterations to avoid early terminations (default: 1000).</li><li><code>z</code> - The quantile of the <code>Normal(0,1)</code> that controls the probability of the stopping criterion being satisfied (default: 3.0).</li><li><code>Cmrl</code> - The inflation factor for the maximum number of iterations the run length may run for (default: 10.0).</li><li><code>maxiter</code> - Maximum number of iterations before the algorithm is forcibly ended (default: 50000).</li><li><code>verbose</code> - Whether to print information to the user about the state of the optimization (default: false).</li><li><code>parallel::Bool</code> - Whether the algorithm should be run in parallel, using available threads (default: false). Parallelization is achieved by averaging <code>Threads.nthreads</code> independent replications of the algorithm, each with precision parameter <code>gamma*sqrt(Threads.nthreads)</code>. See [Capizzi, 2016] for further discussion on parallelizing the SA algorithm.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the estimated control limit <code>h</code>, the total number of iterations <code>iter</code>, and information <code>status</code> about the convergence of the algorithm.</li></ul><p><strong>References</strong></p><ul><li>Capizzi, G., &amp; Masarotto, G. (2016). &quot;Efficient Control Chart Calibration by Simulated Stochastic Approximation&quot;. IIE Transactions 48 (1). https://doi.org/10.1080/0740817X.2015.1055392.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/sacl.jl#L55-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.saCL-Tuple{ControlChart}" href="#SPM.saCL-Tuple{ControlChart}"><code>SPM.saCL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saCL(CH::ControlChart[; rlsim::Function, settings::OptSettings])</code></pre><p>Applies the stochastic approximation algorithm of Capizzi and Masarotto (2016) without modifying the control chart object <code>CH</code>. See the documentation of <code>saCL!</code> for more information about the algorithm and the keyword arguments.</p><p><strong>Returns</strong></p><ul><li>A <code>NamedTuple</code> containing the estimated control limit <code>h</code>, the total number of iterations <code>iter</code>, and information <code>status</code> about the convergence of the algorithm.</li></ul><p><strong>References</strong></p><ul><li>Capizzi, G., &amp; Masarotto, G. (2016). &quot;Efficient Control Chart Calibration by Simulated Stochastic Approximation&quot;. IIE Transactions 48 (1). https://doi.org/10.1080/0740817X.2015.1055392.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/algorithms/control-limit/sacl.jl#L185-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.set_design!-Tuple{SPM.AbstractChart, Any}" href="#SPM.set_design!-Tuple{SPM.AbstractChart, Any}"><code>SPM.set_design!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_design(CH::AbstractChart)</code></pre><p>Set the designs of the control chart statistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.set_limit!-Tuple{SPM.AbstractChart, SPM.AbstractLimit}" href="#SPM.set_limit!-Tuple{SPM.AbstractChart, SPM.AbstractLimit}"><code>SPM.set_limit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function set_limit!(CH::AbstractChart, limit::AbstractLimit)</code></pre><p>Set the control limit of a control chart.</p><p><strong>Returns</strong></p><p>The control limit that has been set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L241-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.set_nominal!-Union{Tuple{C}, Tuple{N}, Tuple{C, N}} where {N&lt;:SPM.NominalProperties, C&lt;:SPM.AbstractChart}" href="#SPM.set_nominal!-Union{Tuple{C}, Tuple{N}, Tuple{C, N}} where {N&lt;:SPM.NominalProperties, C&lt;:SPM.AbstractChart}"><code>SPM.set_nominal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_nominal!(CH::AbstractChart, nominal::NominalProperties)</code></pre><p>Set the nominal properties of a control chart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.set_phase2!-Union{Tuple{C}, Tuple{PH2}, Tuple{C, PH2}} where {PH2&lt;:SPM.AbstractPhase2, C&lt;:SPM.AbstractChart}" href="#SPM.set_phase2!-Union{Tuple{C}, Tuple{PH2}, Tuple{C, PH2}} where {PH2&lt;:SPM.AbstractPhase2, C&lt;:SPM.AbstractChart}"><code>SPM.set_phase2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_phase2!(CH::AbstractChart, phase2::AbstractPhase2)</code></pre><p>Set the Phase 2 information of a control chart to simulate run lenghts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.set_statistic!-Union{Tuple{C}, Tuple{STAT}, Tuple{C, STAT}} where {STAT&lt;:SPM.AbstractStatistic, C&lt;:SPM.AbstractChart}" href="#SPM.set_statistic!-Union{Tuple{C}, Tuple{STAT}, Tuple{C, STAT}} where {STAT&lt;:SPM.AbstractStatistic, C&lt;:SPM.AbstractChart}"><code>SPM.set_statistic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function set_statistic!(CH::AbstractChart, statistic::AbstractStatistic)</code></pre><p>Set the statistic of a control chart.</p><p><strong>Returns</strong></p><p>The statistic that has been set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L192-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.set_t!-Union{Tuple{C}, Tuple{C, Int64}} where C&lt;:SPM.AbstractChart" href="#SPM.set_t!-Union{Tuple{C}, Tuple{C, Int64}} where C&lt;:SPM.AbstractChart"><code>SPM.set_t!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function set_t!(CH::AbstractChart, t)</code></pre><p>Set the current time point of a control chart.</p><p><strong>Returns</strong></p><p>The time point of the statistic that has been set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L207-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.set_value!-Tuple{SPM.AbstractStatistic, Any}" href="#SPM.set_value!-Tuple{SPM.AbstractStatistic, Any}"><code>SPM.set_value!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function set_value!(stat::AbstractStatistic, value)</code></pre><p>Set the value of a statistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/stats-interface.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.set_value!-Union{Tuple{C}, Tuple{C, Any}} where C&lt;:SPM.AbstractChart" href="#SPM.set_value!-Union{Tuple{C}, Tuple{C, Any}} where C&lt;:SPM.AbstractChart"><code>SPM.set_value!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function set_value!(CH::AbstractChart, value)</code></pre><p>Set the value of the statistic of a control chart.</p><p><strong>Returns</strong></p><p>The value of the statistic that has been set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L221-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.shallow_copy_sim-Tuple{ControlChart}" href="#SPM.shallow_copy_sim-Tuple{ControlChart}"><code>SPM.shallow_copy_sim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shallow_copy_sim(CH::AbstractChart)</code></pre><p>Create a shallow copy of a control chart, so that only the statistic and the control limit are copied. This is done to prevent copying eventual Phase 2 data multiple times and thus reduce computational effort when optimizing the control limit and the chart tuning parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.update_chart!-Tuple{SPM.AbstractChart, Any}" href="#SPM.update_chart!-Tuple{SPM.AbstractChart, Any}"><code>SPM.update_chart!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_chart!(CH::AbstractChart, x)</code></pre><p>Update the control chart inplace using a new observation <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.update_chart-Tuple{SPM.AbstractChart, Any}" href="#SPM.update_chart-Tuple{SPM.AbstractChart, Any}"><code>SPM.update_chart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_chart(CH::AbstractChart, x)</code></pre><p>Update the control chart without modifying it using a new observation <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.update_limit!-Union{Tuple{SPM.AbstractChart{S, L, N, P1}}, Tuple{P1}, Tuple{N}, Tuple{L}, Tuple{S}} where {S, L&lt;:SPM.BootstrapLimit, N, P1}" href="#SPM.update_limit!-Union{Tuple{SPM.AbstractChart{S, L, N, P1}}, Tuple{P1}, Tuple{N}, Tuple{L}, Tuple{S}} where {S, L&lt;:SPM.BootstrapLimit, N, P1}"><code>SPM.update_limit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_limit!(CH::AbstractChart, x)</code></pre><p>Update the dynamic control limit of a control chart inplace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/charts/charts-interface.jl#L345-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.update_statistic!-Tuple{SPM.AbstractStatistic, Any}" href="#SPM.update_statistic!-Tuple{SPM.AbstractStatistic, Any}"><code>SPM.update_statistic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_statistic!(stat::AbstractStatistic, x)</code></pre><p>Update a statistic with a new observation x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/stats-interface.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.update_value!-Tuple{SPM.BootstrapLimit, ARL}" href="#SPM.update_value!-Tuple{SPM.BootstrapLimit, ARL}"><code>SPM.update_value!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_value(L::BootstrapLimit, NM::ARL)
get_value(L::BootstrapLimit, NM::QRL)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/limits/dynamic.jl#L32-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.AEWMA" href="#SPM.AEWMA"><code>SPM.AEWMA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AEWMA(λ, k, value)</code></pre><p>Adaptive exponentially weighted moving average with design parameters <code>λ</code>, <code>k</code>, and initial value <code>value</code>.</p><p>The update mechanism based on a new observation <code>x</code> is given by</p><p><span>$value = (1-phi(e))*value + phi(e) * x$</span>,</p><p>where <code>phi(e)</code> is a forecast error function based on the Huber function.</p><p><strong>References</strong></p><p>Capizzi, G. &amp; Masarotto, G. (2003). An Adaptive Exponentially Weighted Moving Average Control Chart. Technometrics, 45(3), 199-207.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/univariate.jl#L100-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.AMCUSUM" href="#SPM.AMCUSUM"><code>SPM.AMCUSUM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AMCUSUM(λ, p; minshift = 0.1, shift = 0.0, Et = zeros(p), t = 0, stat = MCUSUM(k=0.1, p=p))</code></pre><p>A mutable struct representing an Adaptive Multivariate Cumulative Sum (MCUSUM) statistic.</p><p><strong>Arguments</strong></p><ul><li><code>λ::L</code>: The value of λ, where 0.0 &lt;= λ &lt;= 1.0.</li><li><code>p::Int</code>: The number of quality variables to monitor.</li><li><code>minshift::L</code>: The minimum shift value to be detected. Default is 0.1.</li><li><code>shift::L</code>: The current shift value. Default is 0.0.</li><li><code>Et::Vector{V}</code>: The vector Et of smoothed deviations from the zero mean. Has to be exactly equal to <code>zeros(p)</code></li><li><code>t::Int</code>: The current value of time. Has to be exactly 0.</li><li><code>stat::C</code>: The underlying classical MCUSUM statistic. Default is MCUSUM(k=0.1, p=p).</li></ul><p><strong>References</strong></p><ul><li>Dai, Y., Luo, Y., Li, Z., &amp; Wang, Z. (2011). A new adaptive CUSUM control chart for detecting the multivariate process mean. Quality and Reliability Engineering International, 27(7), 877-884. https://doi.org/10.1002/qre.1177</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/multivariate.jl#L127-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.ARL" href="#SPM.ARL"><code>SPM.ARL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ARL(value)</code></pre><p>Value of the in-control average run length of the control chart, i.e. if <span>$RL = \inf{t &gt; 0: \text{Chart detects OC}}$</span> is the run length, then the average run length <span>$ARL$</span> is</p><p><span>$ARL = \mathbb{E}[RL|\tau = +\infty]$</span>,</p><p>where <span>$\{\tau = +\infty\}$</span> represents the process being in-control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/nominal/nominal-interface.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.BlockBootstrap" href="#SPM.BlockBootstrap"><code>SPM.BlockBootstrap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockBootstrap{T} &lt;: AbstractSampling</code></pre><p>Represents a (circular) block bootstrap sampling method.</p><p><strong>Fields</strong></p><ul><li><code>block::T</code>: The current block of data being sampled from.</li><li><code>blocksize::Int</code>: The size of each block.</li><li><code>t::Int</code>: The current index within the block.</li></ul><p><strong>Constructors</strong></p><ul><li><code>BlockBootstrap(blocksize::Int, data::Vector{T}) where T</code>: Constructs a <code>BlockBootstrap</code> object for a vector of data.</li><li><code>BlockBootstrap(blocksize::Int, data::Matrix{T}) where T</code>: Constructs a <code>BlockBootstrap</code> object for a matrix of data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/phase2/tsboot.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.CUSUM" href="#SPM.CUSUM"><code>SPM.CUSUM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CUSUM(k, value, upw::Bool)</code></pre><p>CUSUM statistic with design parameter <code>k</code> and initial value <code>value</code>.</p><p>The update mechanism based on a new observation <code>x</code> is given by:</p><ul><li>if <code>upw == true</code>, then <span>$value = \max\{0, value + x - k\}$</span>;</li><li>if <code>upw == false</code>, then <span>$value = \min\{0, value + x + k\}$</span>.</li></ul><p><strong>References</strong></p><ul><li>Page, E. S. (1954). Continuous Inspection Schemes. Biometrika, 41(1/2), 100. https://doi.org/10.2307/2333009</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/univariate.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.DiagMEWMA" href="#SPM.DiagMEWMA"><code>SPM.DiagMEWMA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MEWMA(Λ, value)</code></pre><p>Exponentially weighted moving average with diagonal smoothing matrix <code>Λ</code> and initial value <code>value</code>.</p><p>The update mechanism based on a new observation <code>x</code> is given by</p><p><span>$Z_t = (I-Λ)*Z_{t-1} + Λ * x_t$</span>,</p><p>and the chart value is defined as</p><p><span>$value_t = Z_t&#39; Λ^(-1) Z_t$</span>.</p><p><strong>References</strong></p><p>Lowry, C. A., Woodall, W. H., Champ, C. W., &amp; Rigdon, S. E. (1992). A Multivariate Exponentially Weighted Moving Average Control Chart. Technometrics, 34(1), 46-53. https://doi.org/10.1080/00401706.1992.10485232</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/multivariate.jl#L34-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.EWMA" href="#SPM.EWMA"><code>SPM.EWMA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EWMA(λ, value)</code></pre><p>Exponentially weighted moving average with design parameter <code>λ</code> and initial value <code>value</code>.</p><p>The update mechanism based on a new observation <code>x</code> is given by</p><p><span>$value = (1-λ)*value + λ * x$</span>.</p><p><strong>References</strong></p><ul><li>Roberts, S. W. (1959). Control Chart Tests Based on Geometric Moving Averages. Technometrics, 1(3), 239-250. https://doi.org/10.1080/00401706.1959.10489860</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/univariate.jl#L31-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.LI2012" href="#SPM.LI2012"><code>SPM.LI2012</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LI2012(x::AbstractMatrix, l::Real; ncuts::AbstractVector = [3 for _ in eachcol(x)], N = 1)</code></pre><p>A mutable struct representing the LI2012 statistic based on data categorization.</p><p><strong>Fields</strong></p><ul><li><code>l::Float64</code>: The exponentially weighted smoothing constant of the statistic.</li><li><code>value::Float64</code>: The initial value of the statistic (default: 0.0).</li><li><code>qtls::Vector{Vector{Float64}}</code>: A vector of quantiles used for data categorization.</li><li><code>f0::Vector{Float64}</code>: The vector of IC cell probabilities, estimated using a loglinear model.</li><li><code>table::Matrix{Float64}</code>: The matrix of cell combinations.</li><li><code>Sigma::Matrix{Float64}</code>: The covariance matrix of the cell counts.</li><li><code>directions::Matrix{Float64}</code>: The matrix of directions to be used in the hypohesis test (see Equation (6) of [Li, 2012]). This is calculated according to the procedure described in Equations (5) and (6) of [Wang, 2017].</li><li><code>N::Int</code>: The number of observations at each time point (default: 1)</li><li><code>z_k::Vector{Float64}</code>: The current vector of smoothed values.</li></ul><p><strong>References</strong></p><ul><li>Li, J., Tsung, F., &amp; Zou, C. (2012). Directional Control Schemes for Multivariate Categorical Processes. Journal of Quality Technology, 44(2), 136â€“154. https://doi.org/10.1080/00224065.2012.11917889</li><li>Wang, J., Li, J., &amp; Su, Q. (2017). Multivariate Ordinal Categorical Process Control Based on Log-Linear Modeling. Journal of Quality Technology, 49(2), 108-122. https://doi.org/10.1080/00224065.2017.11917983</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/LI2012.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.LLCUSUM" href="#SPM.LLCUSUM"><code>SPM.LLCUSUM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LLCUSUM(x::AbstractMatrix, k::Real; ncuts::AbstractVector = [2 for _ in eachcol(x)])</code></pre><p>A mutable struct representing the distibution-free CUSUM statistic based on data categorization.</p><p><strong>Fields</strong></p><ul><li><code>k::Float64</code>: The allowance constant of the CUSUM statistic.</li><li><code>value::Float64</code>: The initial value of the statistic (default: 0.0).</li><li><code>Sobs::Vector{Float64}</code>: The vector of cumulative observed categories.</li><li><code>Sexp::Vector{Float64}</code>: The vector of expected observed categories.</li><li><code>qtls::Vector{Vector{Float64}}</code>: A vector of quantiles used for data categorization.</li><li><code>f0::Vector{Float64}</code>: The vector of IC cell probabilities, estimated using a loglinear model.</li><li><code>table::Matrix{Float64}</code>: The matrix of cell combinations.</li></ul><p><strong>References</strong></p><p>Qiu, P. (2008). Distribution-free multivariate process control based on log-linear modeling. IIE Transactions, 40(7), 664-677. https://doi.org/10.1080/07408170701744843</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/LLCUSUM.jl#L6-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.LocationScaleStatistic" href="#SPM.LocationScaleStatistic"><code>SPM.LocationScaleStatistic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocationScaleStatistic{S, M, P}</code></pre><p>A mutable struct representing a statistic applied to a location-scale family.</p><p><strong>Fields</strong></p><ul><li><code>stat::S</code>: The statistic.</li><li><code>μ::M</code>: The location parameter.</li><li><code>Ω::P</code>: The precision parameter (inverse of the variance).</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">STAT = EWMA(λ = 0.2)
RSTAT = LocationScaleStatistic(STAT, 1.0, 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/residual.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.MCUSUM" href="#SPM.MCUSUM"><code>SPM.MCUSUM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MCUSUM{L,V}(k::L, value::V = 0.0, St::Vector{L})</code></pre><p>A mutable struct representing a Multivariate Cumulative Sum (MCUSUM) statistic.</p><p><strong>Arguments</strong></p><ul><li><code>k::L</code>: The value of the allowance parameter.</li><li><code>value::V</code>: The initial value of the statistic. Default is 0.0.</li><li><code>St::Vector{L}</code>: A vector representing the multivariate cumulative sum at the current time <code>t</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">stat = MCUSUM(0.25, 0.0, [0.0, 0.0])</code></pre><p><strong>References</strong></p><ul><li>Crosier, R. B. (1988). Multivariate Generalizations of Cumulative Sum Quality-Control Schemes. Technometrics, 30(3), 291-303. https://doi.org/10.2307/1270083</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/multivariate.jl#L81-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.MShewhart" href="#SPM.MShewhart"><code>SPM.MShewhart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MShewhart(μ, Σ, value)</code></pre><p>Multivariate Shewhart control chart for observations with mean <code>μ</code>, variance-covariance <code>Σ</code> and initial value <code>value</code>.</p><p>The update mechanism based on a new observation <code>x</code> is given by</p><p><span>$value = (x - μ) Σ^(-1) (x - μ)$</span>.</p><p><strong>References</strong></p><ul><li>Shewhart, W. A. (1931). Economic Control of Quality Of Manufactured Product. D. Van Nostrand Company.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/multivariate.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.OneSidedCurvedLimit" href="#SPM.OneSidedCurvedLimit"><code>SPM.OneSidedCurvedLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OneSidedCurvedLimit(h::Float64, upw::Bool)
OneSidedCurvedLimit(h::Vector{T}, upw::Vector{Bool})</code></pre><p>Curved one-sided limit, such that the run length <span>$RL$</span> of a control chart is the first time <span>$t$</span> in which the statistic <span>$C_t$</span> crosses the limit.</p><ul><li>if <code>upw == true</code>, <span>$RL = \inf\{t : C_t &gt; h\cdot f(t)\}$</span></li><li>if <code>upw == false</code>, <span>$RL = \inf\{t : C_t &lt; -h\cdot f(t)\}$</span></li></ul><p>Note that <code>h &gt; 0</code> by the way it is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/limits/fixed.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.OneSidedFixedLimit" href="#SPM.OneSidedFixedLimit"><code>SPM.OneSidedFixedLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OneSidedFixedLimit(h::Float64, upw::Bool)</code></pre><p>Classical fixed one-sided limit, such that the run length <span>$RL$</span> of a control chart is the first time <span>$t$</span> in which the statistic <span>$C_t$</span> crosses the limit.</p><ul><li>if <code>upw == true</code>, <span>$RL = \inf\{t : C_t &gt; h\}$</span></li><li>if <code>upw == false</code>, <span>$RL = \inf\{t : C_t &lt; h\}$</span></li></ul><p>Note that <code>h &gt; 0</code> by the way it is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/limits/fixed.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.Phase2" href="#SPM.Phase2"><code>SPM.Phase2</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Phase2</code> is a struct that holds the reference sample data and a sampling method to generate new observations from the reference data. </p><p><strong>Arguments</strong></p><ul><li><code>samp = Bootstrap()</code>: The sampling method to be used to generate new observations. Defaults to <code>Bootstrap()</code>.</li><li><code>data</code>: The data obtained after phase 1.</li></ul><p><strong>Examples</strong></p><p>x = randn(500) PH2 = Phase2(data = x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/phase2/phase2-interface.jl#L25-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.Phase2Distribution" href="#SPM.Phase2Distribution"><code>SPM.Phase2Distribution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Phase2Distribution{T} &lt;: AbstractPhase2</code></pre><p>A struct representing Phase II observations, it is used to generate and monitor new data from the true data-generating process. It contains a field <code>dist</code> of type <code>T</code>, which represents the underlying data-generating process.</p><p><strong>Notes</strong></p><p>A method <code>rand(::T)</code> is required to generate new data from <code>dist</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">DGP = Phase2Distribution(Normal(0,1))
new_data(DGP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/phase2/phase2-interface.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.QRL" href="#SPM.QRL"><code>SPM.QRL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QRL(value, qtl)</code></pre><p>Value of the in-control quantile of the run length of the control chart, i.e. if <span>$RL = \inf{t &gt; 0 : \text{Chart detects OC}}$</span> is the run length, then <code>value</code> is the value of the <code>qtl</code>-level quantile of the distribution of <span>$RL$</span> if the process is in-control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/nominal/nominal-interface.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.Shewhart" href="#SPM.Shewhart"><code>SPM.Shewhart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Shewhart(value)</code></pre><p>Shewhart control chart with initial value <code>value</code>.</p><p>The update mechanism based on a new observation <code>x</code> is given by</p><p><span>$value = x$</span>.</p><p><strong>References</strong></p><ul><li>Shewhart, W. A. (1931). Economic Control of Quality Of Manufactured Product. D. Van Nostrand Company.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/univariate.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.StationaryBootstrap" href="#SPM.StationaryBootstrap"><code>SPM.StationaryBootstrap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StationaryBootstrap{T} &lt;: AbstractSampling</code></pre><p>Represents a stationary block bootstrap sampling method, where the block length is sampled from a <code>Geometric</code> random variable.</p><p><strong>Fields</strong></p><ul><li><code>block::T</code>: The current block of data being sampled from.</li><li><code>blocksize::Int</code>: The average size of each block.</li><li><code>t::Int</code>: The current index within the block.</li></ul><p><strong>Constructors</strong></p><ul><li><code>StationaryBootstrap(blocksize::Int, data::Vector{T}) where T</code>: Constructs a <code>StationaryBootstrap</code> object for a vector of data.</li><li><code>StationaryBootstrap(blocksize::Int, data::Matrix{T}) where T</code>: Constructs a <code>StationaryBootstrap</code> object for a matrix of data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/phase2/tsboot.jl#L77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.TwoSidedCurvedLimit" href="#SPM.TwoSidedCurvedLimit"><code>SPM.TwoSidedCurvedLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoSidedCurvedLimit(h::Float64)
TwoSidedCurvedLimit(h::Vector{T})</code></pre><p>Curved one-sided limit, such that the run length <span>$RL$</span> of a control chart is the first time <span>$t$</span> in which the statistic <span>$C_t$</span> crosses the limit.</p><p><span>$RL = \inf\{t &gt; 0 : |C_t| &gt; h\cdot f(t)\}$</span>.</p><p>Note that <code>h &gt; 0</code> by the way it is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/limits/fixed.jl#L87-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.TwoSidedFixedLimit" href="#SPM.TwoSidedFixedLimit"><code>SPM.TwoSidedFixedLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoSidedFixedLimit(h::Float64)</code></pre><p>Classical fixed two-sided limit, such that the run length <span>$RL$</span> of a control chart is the first time <span>$t$</span> in which the statistic <span>$C_t$</span> crosses the limit:</p><p><span>$RL = \inf\{t &gt; 0 : |C_t| &gt; h\}$</span>.</p><p>Note that <code>h &gt; 0</code> by the way it is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/limits/fixed.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPM.WANG2017" href="#SPM.WANG2017"><code>SPM.WANG2017</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WANG2017(x::AbstractMatrix, l::Real; ncuts::AbstractVector = [3 for _ in eachcol(x)], N = 1)</code></pre><p>A mutable struct representing the WANG2017 statistic based on data categorization.</p><p><strong>Fields</strong></p><ul><li><code>l::Float64</code>: The exponentially weighted smoothing constant of the statistic.</li><li><code>value::Float64</code>: The initial value of the statistic (default: 0.0).</li><li><code>qtls::Vector{Vector{Float64}}</code>: A vector of quantiles used for data categorization.</li><li><code>f0::Vector{Float64}</code>: The vector of IC cell probabilities, estimated using a loglinear model.</li><li><code>table::Matrix{Float64}</code>: The matrix of cell combinations.</li><li><code>inv_VCOV::Matrix{Float64}</code>: The matrix containing the inverse covariance to be used in the running statistic.</li><li><code>N::Int</code>: The number of observations at each time point (default: 1)</li><li><code>z_k::Vector{Float64}</code>: The current vector of smoothed values.</li></ul><p><strong>References</strong></p><p>Wang, J., Li, J., &amp; Su, Q. (2017). Multivariate Ordinal Categorical Process Control Based on Log-Linear Modeling. Journal of Quality Technology, 49(2), 108-122. https://doi.org/10.1080/00224065.2017.11917983</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DedZago/SPM.jl/blob/c58cdad120694b58895f6c18271d25edba57ef7f/src/statistics/categorization/WANG2017.jl#L6-L24">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 8 September 2023 14:07">Friday 8 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
