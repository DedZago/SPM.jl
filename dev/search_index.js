var documenterSearchIndex = {"docs":
[{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Modules = [SPM]\nPages = [\"interface.jl\", \"bisectioncl.jl\", \"double-bootstrap.jl\", \"sacl.jl\", \"optsettings.jl\", \"grid-search.jl\", \"nlopt.jl\"]","category":"page"},{"location":"optimization/#SPM.Phase2","page":"Optimization","title":"SPM.Phase2","text":"Phase2 is a struct that holds the reference sample data and a sampling method to generate new observations from the reference data. \n\nArguments\n\nsamp = Bootstrap(): The sampling method to be used to generate new observations. Defaults to Bootstrap().\ndata: The data obtained after phase 1.\n\nExamples\n\nx = randn(500) PH2 = Phase2(data = x)\n\n\n\n\n\n","category":"type"},{"location":"optimization/#SPM.Phase2Distribution","page":"Optimization","title":"SPM.Phase2Distribution","text":"Phase2Distribution{T} <: AbstractPhase2\n\nA struct representing Phase II observations, it is used to generate and monitor new data from the true data-generating process. It contains a field dist of type T, which represents the underlying data-generating process.\n\nNotes\n\nA method rand(::T) is required to generate new data from dist.\n\nExample\n\nDGP = Phase2Distribution(Normal(0,1))\nnew_data(DGP)\n\n\n\n\n\n","category":"type"},{"location":"optimization/#SPM.get_design-Tuple{SPM.AbstractStatistic}","page":"Optimization","title":"SPM.get_design","text":"get_design(stat::AbstractStatistic)\n\nGet the vector of hyperparameters of a statistic.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.get_maxrl-Tuple{SPM.AbstractStatistic}","page":"Optimization","title":"SPM.get_maxrl","text":"get_maxrl(stat::AbstractStatistic)\nget_maxrl(stat::Vector{T <: AbstractStatistics})\n\nGet the maximum value of the run length for a statistic stat.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.get_value-Tuple{SPM.AbstractStatistic}","page":"Optimization","title":"SPM.get_value","text":"get_value(stat::AbstractStatistic)\n\nGet the current value of a statistic.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.new_data-Tuple{Phase2}","page":"Optimization","title":"SPM.new_data","text":"new_data(PH2::Phase2{S,T})\nnew_data(PH2::Phase2{S,AbstractVector})\nnew_data(PH2::Phase2{S,AbstractMatrix})\n\nGenerates a new observation based on the observed Phase II (in-control) data.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.optimize_design","page":"Optimization","title":"SPM.optimize_design","text":"optimize_design(CH::ControlChart, rlsim_oc::Function, settings::OptSettings=OptSettings(CH); optimizer::Symbol = :LN_BOBYQA, solver::Symbol = :SACL, nsims_opt::Int = 1000, kw...)\n\nOptimizes the design of a control chart using a specified optimization algorithm.\n\nArguments\n\nCH::ControlChart: The control chart object to optimize.\nrlsim_oc::Function: A function that simulates the out-of-control state of the control chart.\nsettings::OptSettings: The optimization settings that control the optimization routine (default: OptSettings(CH)).\n\nKeyword Arguments\n\noptimizer::Symbol: The optimization algorithm to use (default: :LN_BOBYQA).\nsolver::Symbol: The root-finding algorithm to use for control limit estimation (default: :Bootstrap).\nhmax::Float64: The maximum value of the control limit, used only for the bisection algorithm (default: 100.0)\nkw...: Additional keyword arguments to pass to the solver algorithm.\n\nReturns\n\nThe optimized design parameters of the control chart.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#SPM.optimize_design!","page":"Optimization","title":"SPM.optimize_design!","text":"optimize_design!(CH::ControlChart, rlsim_oc::Function, settings::OptSettings=OptSettings(CH); optimizer = :LN_BOBYQA, solver = :Bootstrap, hmax::Float64 = 20.0, kw...)\n\nOptimizes the design of a control chart CH using a specified optimization algorithm.\n\nArguments\n\nCH::ControlChart: The control chart object to optimize.\nrlsim_oc::Function: A function that simulates the out-of-control state of the control chart.\nsettings::OptSettings: The optimization settings that control the optimization routine (default: OptSettings(CH)).\n\nKeyword Arguments\n\noptimizer::Symbol: The optimization algorithm to use (default: :LN_BOBYQA).\nsolver::Symbol: The root-finding algorithm to use for control limit estimation (default: :Bootstrap).\nhmax::Float64: The maximum value of the control limit, used only when the solver is set to :Bisection (default: 100.0)\nkw...: Additional keyword arguments to pass to the solver algorithm.\n\nReturns\n\nThe optimized design parameters of the control chart.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#SPM.optimize_limit","page":"Optimization","title":"SPM.optimize_limit","text":"optimize_limit(CH::ControlChart, solver::Symbol = :Bootstrap; kw...)\n\nOptimizes the control limit of a ControlChart object, without modifying the original ControlChart object.\n\nArguments\n\nCH::ControlChart: The ControlChart object to optimize.\nsolver::Symbol: The solver algorithm to use (default: :Bootstrap).\n\nKeyword Arguments\n\nhmax::Float64: The maximum value of the control limit. Used only for the bisection algorithm (default: 100.0)\nkw...: Additional keyword arguments to pass to the algorithm.\n\nReturns\n\nThe optimized control limit value.\n\nRaises\n\nValueError: If the optimization method specified in settings is unknown.\n\nExample\n\noptimize_limit(my_chart, settings=OptSettings(ic_solver=:SA))\n\n\n\n\n\n","category":"function"},{"location":"optimization/#SPM.optimize_limit!","page":"Optimization","title":"SPM.optimize_limit!","text":"optimize_limit(CH::ControlChart, solver = :Bootstrap; hmax = 20.0, kw...)\n\nOptimizes the control limit of a ControlChart object.\n\nArguments\n\nCH::ControlChart: The ControlChart object to optimize.\nsolver::Symbol: The solver algorithm to use (default: :Bootstrap).\n\nKeyword Arguments\n\nhmax::Float64: The maximum value of the control limit. Only used for the bisection algorithm (default: 100.0)\nkw...: Additional keyword arguments to pass to the algorithm.\n\nReturns\n\nThe optimized control limit value.\n\nRaises\n\nValueError: If the optimization method specified in settings is unknown.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#SPM.set_design!-Tuple{SPM.AbstractStatistic, AbstractVector}","page":"Optimization","title":"SPM.set_design!","text":"set_design!(stat::AbstractStatistic, par::AbstractVector)\n\nSet the vector of hyperparameters of a statistic.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.set_value!-Tuple{SPM.AbstractStatistic, Any}","page":"Optimization","title":"SPM.set_value!","text":"function set_value!(stat::AbstractStatistic, value)\n\nSet the value of a statistic.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.update_statistic!-Tuple{SPM.AbstractStatistic, Any}","page":"Optimization","title":"SPM.update_statistic!","text":"update_statistic!(stat::AbstractStatistic, x)\n\nUpdate a statistic with a new observation x\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.bisectionCL!-Tuple{ControlChart, Any}","page":"Optimization","title":"SPM.bisectionCL!","text":"bisectionCL!(CH::ControlChart, hmax[; rlsim::Function, settings::OptSettings, kw...])\n\nComputes the control limit to satisfy the nominal properties of a control chart, using the bisection algorithm (see for instance Qiu, 2013)\n\nArguments\n\nCH - A control chart.\nhmax - The maximum value for the control limit.\n\nKeyword arguments\n\nrlsim - A function that generates a run length for the control chart with signature rlsim(CH; maxiter). If left unspecified, defaults to run_sim. See the help for run_sim for more information about the signature of the function.\nnsims - The number of run lengths used to estimate the target nominal property (default: 10000).\nhmin - The minimum value of the control limit, (default: sqrt(eps())).\nmaxiter - The maximum number of bisection iterations (default: 30).\nmaxrl - The value at which to maxrlate the run length, to avoid excessive computations (default: Inf, i.e. no maxrlation).\nx_tol - Absolute tolerance for the algorithm, which is terminated if   h^(k+1) - h^(k)  x_texttol   (default: 1e-06)\nf_tol - Absolute tolerance for the algorithm, which is terminated if   texttarget(h^(k+1)) - texttarget(h^(k))  f_texttol   (default: 1.0)\nverbose - Whether to print information to the user about the state of the optimization (default: false).\nparallel::Bool - Whether the algorithm should be run in parallel, using available threads (default: false)\n\nReturns\n\nA NamedTuple containing the estimated control limit h, the total number of iterations iter, and information status about the convergence of the algorithm.\n\nReferences\n\nQiu, P. (2013). Introduction to Statistical Process Control. Boca Raton: CRC Press.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.bisectionCL-Tuple{ControlChart, Any}","page":"Optimization","title":"SPM.bisectionCL","text":"bisectionCL(CH::ControlChart, hmax; kw...)\n\nApplies the bisection algorithm to find the control limit of a control chart without modifying the control chart object CH.\n\nKeyword arguments\n\nSee the documentation of bisectionCL! for more information about the algorithm and keyword arguments.\n\nReturns\n\nA NamedTuple containing the estimated control limit h, the total number of iterations iter, and information status about the convergence of the algorithm.\n\nReferences\n\nQiu, P. (2013). Introduction to Statistical Process Control. CRC Press.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.combinedCL!-Tuple{ControlChart}","page":"Optimization","title":"SPM.combinedCL!","text":"combinedCL!(CH::ControlChart[; rlsim::Function, settings::OptSettings, kw...])\n\nComputes the control limit to satisfy the nominal properties of a control chart, using the bisection algorithm (see for instance Qiu, 2013). The control limit upper bound hmax for the bisection algorithm is found using the stochastic approximation algorithm of Capizzi and Masarotto (2016)\n\nArguments\n\nCH - A control chart.\n\nKeyword arguments\n\ninflate::Real - An inflation constant for the starting control limit value so that, on average, the first iteration will move the control limit to lower values. This usually saves computational time (default: 1.05).\nparallel::Bool - Whether the algorithm should be run in parallel, using available threads (default: false)\n\nBisection algorithm\n\nrlsim - A function that generates a run length for the control chart with signature rlsim(CH; maxiter). If left unspecified, defaults to run_sim. See the help for run_sim for more information about the signature of the function.\nnsims - The number of run lengths used to estimate the target nominal property (default: 10000).\nhmin - The minimum value of the control limit, (default: sqrt(eps())).\nmaxiter - The maximum number of bisection iterations (default: 30).\nmaxrl - The value at which to maxrlate the run length, to avoid excessive computations (default: Inf, i.e. no maxrlation).\nx_tol - Absolute tolerance for the algorithm, which is terminated if   h^(k+1) - h^(k)  x_texttol   (default: 1e-06)\nf_tol - Absolute tolerance for the algorithm, which is terminated if   texttarget(h^(k+1)) - texttarget(h^(k))  f_texttol   (default: 1.0)\n\nSA algorithm\n\nNfixed - The number of iterations for the gain estimation stage (default: 200).\nAfixed - The fixed gain during the gain estimation stage (default: 0.1).\nAmin - The minimum allowed value of gain (default: 0.1).\nAmax - The maximum allowed value of gain (default: 100).\ndeltaSA - The shift in control limit used during the gain estimation stage (default: 0.1).\nq - The power that controls the denominator in the Robbins-Monro algorithm (default: 0.55).\ngamma - The precision parameter for the stopping criterion of the algorithm (default: 0.05).\nNmin - The minimum number of iterations required for the algorithm to end (default: 200).\nz - The quantile of the Normal(0,1) that controls the probability of the stopping criterion being satisfied (default: 3.0).\nCmrl - The inflation factor for the maximum number of iterations the run length may run for (default: 10.0).\nmaxiter_sa - Maximum number of iterations before the algorithm is forcibly ended (default: 200).\nverbose - Whether to print information to the user about the state of the optimization (default: false).\n\nReturns\n\nA NamedTuple containing the estimated control limit h, the total number of iterations iter, and information status about the convergence of the algorithm.\n\nReferences\n\nQiu, P. (2013). Introduction to Statistical Process Control. Boca Raton: CRC Press.\nCapizzi, G., & Masarotto, G. (2016). Efficient control chart calibration by simulated stochastic approximation. IIE Transactions, 48(1), 57-65. https://doi.org/10.1080/0740817X.2015.1055392\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.combinedCL-Tuple{ControlChart}","page":"Optimization","title":"SPM.combinedCL","text":"combinedCL(CH::ControlChart; kw...)\n\nApplies the bisection algorithm to find the control limit of a control chart without modifying the control chart object CH. The control limit upper bound hmax for the bisection algorithm is found using the stochastic approximation algorithm of Capizzi and Masarotto (2016). See the documentation of combinedCL! for more information about the algorithm and keyword arguments.\n\nKeyword arguments\n\nSee the documentation of combinedCL! for a list of keyword arguments.\n\nReturns\n\nA NamedTuple containing the estimated control limit h, the total number of iterations iter, and information status about the convergence of the algorithm.\n\nReferences\n\nQiu, P. (2013). Introduction to Statistical Process Control. Boca Raton: CRC Press.\nCapizzi, G., & Masarotto, G. (2016). Efficient control chart calibration by simulated stochastic approximation. IIE Transactions, 48(1), 57-65. https://doi.org/10.1080/0740817X.2015.1055392\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.bootstrapCL!-Tuple{ControlChart}","page":"Optimization","title":"SPM.bootstrapCL!","text":"bootstrapCL!(CH::ControlChart[; rlsim::Function, settings::OptSettings])\n\nComputes the control limit to satisfy the nominal properties of a control chart, using the bisection algorithm on bootstrapped paths (see for instance Qiu, 2013).\n\nArguments\n\nCH - A control chart.\n\nKeyword arguments\n\nrlsim - A function that generates a path of the control chart statistic with signature rlsim(CH; maxiter). If left unspecified, defaults to run_path_sim. See the help for run_path_sim for more information about the signature of the function.\nsettings - An OptSettings objects which contains variables that control the behaviour of the algorithm. See the Accepted settings section below for information about the settings that control the behaviour of the algorithm. For more information about the specifics of each keyword argument, see for instance Qiu (2013).\nmaxiter - The maximum number of bisection iterations.\nnsims - The number of run lengths used to estimate the target nominal property.\nmaxrl - The maximum run length after which the run length is truncated, to avoid excessive computations.\nx_tol - Absolute tolerance for the algorithm, which is ended if   h^(k+1) - h^(k)  x_texttol\nf_tol - Absolute tolerance for the algorithm, which is ended if   texttarget(h^(k+1)) - texttarget(h^(k))  f_texttol\n\nReturns\n\nA NamedTuple containing the estimated control limit h, the total number of iterations iter, and information status about the convergence of the algorithm.\n\nReferences\n\nQiu, P. (2013). Introduction to Statistical Process Control. Boca Raton: CRC Press.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.bootstrapCL-Tuple{ControlChart}","page":"Optimization","title":"SPM.bootstrapCL","text":"bootstrapCL(CH::ControlChart; kw...)\n\nApplies the bisection algorithm on simulated run length paths to find the control limit of a control chart without modifying the control chart object CH.\n\nKeyword arguments\n\nSee the documentation of bootstrapCL! for more information about the algorithm and keyword arguments.\n\nReturns\n\nA NamedTuple containing the estimated control limit h, the total number of iterations iter, and information status about the convergence of the algorithm.\n\nReferences\n\nQiu, P. (2013). Introduction to Statistical Process Control. Boca Raton: CRC Press.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.calculate_limit_gradient-Tuple{SPM.AbstractChart, Any}","page":"Optimization","title":"SPM.calculate_limit_gradient","text":"calculate_limit_gradient(CH::AbstractChart, rl::Real)\ncalculate_limit_gradient(nominal::ARL, rl)\ncalculate_limit_gradient(nominal::QRL, rl)\n\nCalculate the gradient for the optimization of the control limit.\n\nIf the control chart nominal attribute is of type ARL, then the gradient is calculated according to Equation (9) of Capizzi and Masarotto (2016).\n\nIf the control chart nominal attribute is of type QRL, then the gradient is calculated using the recursion on page 280 of Capizzi and Masarotto (2009)\n\nReferences\n\nCapizzi, G., & Masarotto, G. (2016). \"Efficient Control Chart Calibration by Simulated Stochastic Approximation\". IIE Transactions 48 (1). https://doi.org/10.1080/0740817X.2015.1055392.\n\nCapizzi, G. & Masarotto, G. (2009) Bootstrap-based design of residual control charts, IIE Transactions, 41:4, 275-286, DOI: https://doi.org/10.1080/07408170802120059 \n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.saCL!-Tuple{ControlChart}","page":"Optimization","title":"SPM.saCL!","text":"saCL!(CH::ControlChart[; rlsim::Function, settings::OptSettings])\n\nComputes the control limit to satisfy the nominal properties of a control chart, using the stochastic approximation algorithm described in Capizzi and Masarotto (2016).\n\nArguments\n\nCH - A control chart.\n\nKeyword arguments\n\nrlsim - A function that generates new data with signature rlsim(CH; maxiter, delta). If left unspecified, defaults to run_sim_sa. See the help for run_sim_sa for more information about the requirements of the function.\nsettings - An OptSettings objects which contains variables that control the behaviour of the algorithm. See the Accepted settings section below for information about the settings that control the behaviour of the algorithm. For more information about the specifics of each keyword argument, see Capizzi and Masarotto (2016).\nNfixed - The number of iterations for the gain estimation stage (default: 500).\nAfixed - The fixed gain during the gain estimation stage (default: 0.1).\nAmin - The minimum allowed value of gain (default: 0.1).\nAmax - The maximum allowed value of gain (default: 100.0).\ndelta_sa - The shift in control limit used during the gain estimation stage (default: 0.1).\nq - The power that controls the denominator in the Robbins-Monro algorithm (default: 0.55).\ngamma - The precision parameter for the stopping criterion of the algorithm (default: 0.02).\nNmin - The minimum number of iterations to avoid early terminations (default: 1000).\nz - The quantile of the Normal(0,1) that controls the probability of the stopping criterion being satisfied (default: 3.0).\nCmrl - The inflation factor for the maximum number of iterations the run length may run for (default: 10.0).\nmaxiter - Maximum number of iterations before the algorithm is forcibly ended (default: 50000).\nverbose - Whether to print information to the user about the state of the optimization (default: false).\nparallel::Bool - Whether the algorithm should be run in parallel, using available threads (default: false). Parallelization is achieved by averaging Threads.nthreads independent replications of the algorithm, each with precision parameter gamma*sqrt(Threads.nthreads). See [Capizzi, 2016] for further discussion on parallelizing the SA algorithm.\n\nReturns\n\nA NamedTuple containing the estimated control limit h, the total number of iterations iter, and information status about the convergence of the algorithm.\n\nReferences\n\nCapizzi, G., & Masarotto, G. (2016). \"Efficient Control Chart Calibration by Simulated Stochastic Approximation\". IIE Transactions 48 (1). https://doi.org/10.1080/0740817X.2015.1055392.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.saCL-Tuple{ControlChart}","page":"Optimization","title":"SPM.saCL","text":"saCL(CH::ControlChart[; rlsim::Function, settings::OptSettings])\n\nApplies the stochastic approximation algorithm of Capizzi and Masarotto (2016) without modifying the control chart object CH.\n\nKeyword arguments\n\nSee the documentation of saCL! for more information about the algorithm and the keyword arguments.\n\nReturns\n\nA NamedTuple containing the estimated control limit h, the total number of iterations iter, and information status about the convergence of the algorithm.\n\nReferences\n\nCapizzi, G., & Masarotto, G. (2016). \"Efficient Control Chart Calibration by Simulated Stochastic Approximation\". IIE Transactions 48 (1). https://doi.org/10.1080/0740817X.2015.1055392.\n\n\n\n\n\n","category":"method"},{"location":"optimization/#SPM.optimize_grid-Tuple{ControlChart, Function, OptSettings}","page":"Optimization","title":"SPM.optimize_grid","text":"optimize_grid(CH::ControlChart, rlconstr::Function, settings::OptSettings)\n\nOptimizes a control chart by finding the best set of parameters using a grid search.\n\nArguments\n\nCH::ControlChart: The control chart object whose parameters must be optimized.\nrlconstr::Functiom: The function that evaluates the OC performance of the control chart.\nsettings::OptSettings: The optimization settings.\n\nReturns\n\npar_current (Vector{Float64}): the optimal set of parameters found by the optimization algorithm.\n\nReferences\n\nQiu, P. (2008). Distribution-Free Multivariate Process Control Based on Log-Linear Modeling. IIE Transactions, 40(7), 664-677. https://doi.org/10.1080/07408170701744843\n\n\n\n\n\n","category":"method"},{"location":"monitoring_risk_adjusted/#Monitoring-risk-adjusted-surgical-outcomes","page":"Monitoring risk-adjusted surgical outcomes","title":"Monitoring risk-adjusted surgical outcomes","text":"","category":"section"},{"location":"using_control_charts/#Setting-up-a-control-chart","page":"Setting up a control chart","title":"Setting up a control chart","text":"","category":"section"},{"location":"monitoring_nonparametric_profiles/#Monitoring-nonparametric-profiles","page":"Monitoring nonparametric profiles","title":"Monitoring nonparametric profiles","text":"","category":"section"},{"location":"nominal_properties/#Nominal-properties","page":"Nominal properties","title":"Nominal properties","text":"","category":"section"},{"location":"nominal_properties/","page":"Nominal properties","title":"Nominal properties","text":"Modules = [SPM]\nPages = [\"nominal-interface.jl\"]","category":"page"},{"location":"nominal_properties/#SPM.ARL","page":"Nominal properties","title":"SPM.ARL","text":"ARL(value)\n\nValue of the in-control average run length of the control chart, i.e. if RL = inft  0 textChart detects OC is the run length, then the average run length ARL is\n\nARL = mathbbERLtau = +infty,\n\nwhere tau = +infty represents the process being in-control.\n\n\n\n\n\n","category":"type"},{"location":"nominal_properties/#SPM.QRL","page":"Nominal properties","title":"SPM.QRL","text":"QRL(value, qtl)\n\nValue of the in-control quantile of the run length of the control chart, i.e. if RL = inft  0  textChart detects OC is the run length, then value is the value of the qtl-level quantile of the distribution of RL if the process is in-control.\n\n\n\n\n\n","category":"type"},{"location":"control_limits/#Control-limits","page":"Control limits","title":"Control limits","text":"","category":"section"},{"location":"control_limits/","page":"Control limits","title":"Control limits","text":"Modules = [SPM]\nPages = [\"limits-interface.jl\", \"fixed.jl\", \"dynamic.jl\"]","category":"page"},{"location":"control_limits/#SPM.OneSidedFixedLimit","page":"Control limits","title":"SPM.OneSidedFixedLimit","text":"OneSidedFixedLimit(h::Float64, upw::Bool)\n\nClassical fixed one-sided limit, such that the run length RL of a control chart is the first time t in which the statistic C_t crosses the limit.\n\nif upw == true, RL = inft  C_t  h\nif upw == false, RL = inft  C_t  h\n\nNote that by definition, h > 0.\n\n\n\n\n\n","category":"type"},{"location":"control_limits/#SPM.TwoSidedFixedLimit","page":"Control limits","title":"SPM.TwoSidedFixedLimit","text":"TwoSidedFixedLimit(h::Float64)\n\nClassical fixed two-sided limit, such that the run length RL of a control chart is the first time t in which the statistic C_t crosses the limit:\n\nRL = inft  0  C_t  h.\n\nNote that by definition, h > 0.\n\n\n\n\n\n","category":"type"},{"location":"control_limits/#SPM.OneSidedBootstrapLimit","page":"Control limits","title":"SPM.OneSidedBootstrapLimit","text":"OneSidedBootstrapLimit{T} <: BootstrapLimit{T}\n\nA one-sided bootstrap limit with constant false-alarm rate.\n\nFields\n\nsim::Vector{T}: The vector of simulated statistics.\nh::T: The current value of the control limit.\nupw::Bool: Whether the control limit is an upper or lower control limit.\n\nConstructors\n\nOneSidedBootstrapLimit(S::AbstractStatistic, upw, B::Int): Create a new OneSidedBootstrapLimit object. The argument S is an AbstractStatistic object. The argument upw determines whether the bootstrap is one-sided and upper-tailed or lower-tailed. The argument B is an integer indicating the number of bootstrap replications.\n\n\n\n\n\n","category":"type"},{"location":"control_limits/#SPM.OneSidedCurvedLimit","page":"Control limits","title":"SPM.OneSidedCurvedLimit","text":"OneSidedCurvedLimit(h::Float64, upw::Bool)\nOneSidedCurvedLimit(h::Vector{T}, upw::Vector{Bool})\n\nCurved one-sided limit, such that the run length RL of a control chart is the first time t in which the statistic C_t crosses the limit.\n\nif upw == true, RL = inft  C_t  hcdot f(t)\nif upw == false, RL = inft  C_t  -hcdot f(t)\n\nNote that by definition, h > 0.\n\n\n\n\n\n","category":"type"},{"location":"control_limits/#SPM.TwoSidedBootstrapLimit","page":"Control limits","title":"SPM.TwoSidedBootstrapLimit","text":"TwoSidedBootstrapLimit{T} <: BootstrapLimit{T}\n\nA two-sided bootstrap limit with constant false-alarm rate.\n\nFields\n\nsim::Vector{T}: The vector of simulated statistics.\nh::Vector{T}: The current value of the control limits.\n\nConstructors\n\nTwoSidedBootstrapLimit(S::AbstractStatistic, B::Int): Create a new TwoSidedBootstrapLimit object. The argument S is an AbstractStatistic object. The argument B is an integer indicating the number of bootstrap replications.\n\n\n\n\n\n","category":"type"},{"location":"control_limits/#SPM.TwoSidedCurvedLimit","page":"Control limits","title":"SPM.TwoSidedCurvedLimit","text":"TwoSidedCurvedLimit(h::Float64)\nTwoSidedCurvedLimit(h::Vector{T})\n\nCurved one-sided limit, such that the run length RL of a control chart is the first time t in which the statistic C_t crosses the limit.\n\nRL = inft  0  C_t  hcdot f(t).\n\nNote that by definition, h > 0.\n\n\n\n\n\n","category":"type"},{"location":"control_limits/#SPM.update_value!-Tuple{SPM.BootstrapLimit, ARL}","page":"Control limits","title":"SPM.update_value!","text":"update_value!(L::BootstrapLimit, NM::ARL)\nupdate_value!(L::BootstrapLimit, NM::QRL)\n\nUpdate the value of the BootstrapLimit object using the nominal value obtained from the ARL or QRL object.\n\nArguments\n\nL::BootstrapLimit: The BootstrapLimit object to be updated.\nNM: The ARL or QRL object used to obtain the value for the update.\n\n\n\n\n\n","category":"method"},{"location":"monitoring_mean_covariance/#Joint-monitoring-of-mean-and-covariance-matrix","page":"Joint monitoring of mean and covariance matrix","title":"Joint monitoring of mean and covariance matrix","text":"","category":"section"},{"location":"phase_2/#Phase-2","page":"Phase 2","title":"Phase 2","text":"","category":"section"},{"location":"phase_2/","page":"Phase 2","title":"Phase 2","text":"Modules = [SPM]\nPages = [\"phase2-interface.jl\", \"bootstrap.jl\"]","category":"page"},{"location":"phase_2/#SPM.BlockBootstrap","page":"Phase 2","title":"SPM.BlockBootstrap","text":"BlockBootstrap{T} <: AbstractSampling\n\nRepresents a (circular) block bootstrap sampling method.\n\nFields\n\nblock::T: The current block of data being sampled from.\nblocksize::Int: The size of each block.\nt::Int: The current index within the block.\n\nConstructors\n\nBlockBootstrap(blocksize::Int, data::Vector{T}) where T: Constructs a BlockBootstrap object for a vector of data.\nBlockBootstrap(blocksize::Int, data::Matrix{T}) where T: Constructs a BlockBootstrap object for a matrix of data.\n\n\n\n\n\n","category":"type"},{"location":"phase_2/#SPM.StationaryBootstrap","page":"Phase 2","title":"SPM.StationaryBootstrap","text":"StationaryBootstrap{T} <: AbstractSampling\n\nRepresents a stationary block bootstrap sampling method, where the block length is sampled from a Geometric random variable.\n\nFields\n\nblock::T: The current block of data being sampled from.\nblocksize::Int: The average size of each block.\nt::Int: The current index within the block.\n\nConstructors\n\nStationaryBootstrap(blocksize::Int, data::Vector{T}) where T: Constructs a StationaryBootstrap object for a vector of data.\nStationaryBootstrap(blocksize::Int, data::Matrix{T}) where T: Constructs a StationaryBootstrap object for a matrix of data.\n\n\n\n\n\n","category":"type"},{"location":"control_charts/#Control-charts","page":"Control charts","title":"Control charts","text":"","category":"section"},{"location":"control_charts/","page":"Control charts","title":"Control charts","text":"Modules = [SPM]\nPages = [\"charts-interface.jl\", \"simulate.jl\", \"retrospective.jl\"]","category":"page"},{"location":"control_charts/#SPM.get_design-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_design","text":"get_design(CH::AbstractChart)\n\nGet the designs of the control chart statistic.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_limit-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_limit","text":"get_limit(CH::AbstractChart)\n\nGet the control limit of a control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_limit_value-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_limit_value","text":"get_limit_value(CH::AbstractChart)\n\nGet the control limit value of a control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_maxrl-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_maxrl","text":"get_maxrl(CH::AbstractChart)\n\nGet the maximum run length of the control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_nominal-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_nominal","text":"get_nominal(CH::AbstractChart)\n\nGet the nominal properties of a control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_nominal_value-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_nominal_value","text":"get_nominal(CH::AbstractChart)\n\nGet the nominal value of a control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_phase2-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_phase2","text":"get_phase2(CH::AbstractChart)\n\nGet the phase 2 information of a control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_statistic-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_statistic","text":"get_statistic(CH::AbstractChart)\n\nGet the statistic of a control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_t-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_t","text":"get_t(CH::AbstractChart)\n\nGet the current time point of a control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.get_value-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.get_value","text":"get_value(CH::AbstractChart)\n\nGet the current value of the control chart statistic.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.is_IC-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.is_IC","text":"is_IC(CH::AbstractChart)\nis_OC(CH::AbstractChart)\n\nCheck whether the control chart is in control or out of control.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.is_IC_vec-Tuple{MultipleControlChart}","page":"Control charts","title":"SPM.is_IC_vec","text":"is_IC_vec(CH::MultipleControlChart)\nis_OC_vec(CH::MultipleControlChart)\n\nCheck whether each individual control chart that makes up a multiple control chart is in control or out of control.\n\nReturns\n\nA vector of Bool, whose length is the number of individual statistics.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.new_data!-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.new_data!","text":"new_data(CH::AbstractChart)\n\nSimulate a new observation for the control chart from the phase 2 data, eventually modifying the underlying phase 2 object.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.new_data-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.new_data","text":"new_data(CH::AbstractChart)\n\nSimulate a new observation for the control chart from the phase 2 data.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.set_design!-Tuple{SPM.AbstractChart, Any}","page":"Control charts","title":"SPM.set_design!","text":"get_design(CH::AbstractChart)\n\nSet the designs of the control chart statistic.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.set_limit!-Tuple{SPM.AbstractChart, SPM.AbstractLimit}","page":"Control charts","title":"SPM.set_limit!","text":"function set_limit!(CH::AbstractChart, limit::AbstractLimit)\n\nSet the control limit of a control chart.\n\nReturns\n\nThe control limit that has been set.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.set_nominal!-Union{Tuple{C}, Tuple{N}, Tuple{C, N}} where {N<:SPM.NominalProperties, C<:SPM.AbstractChart}","page":"Control charts","title":"SPM.set_nominal!","text":"set_nominal!(CH::AbstractChart, nominal::NominalProperties)\n\nSet the nominal properties of a control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.set_phase2!-Union{Tuple{C}, Tuple{PH2}, Tuple{C, PH2}} where {PH2<:SPM.AbstractPhase2, C<:SPM.AbstractChart}","page":"Control charts","title":"SPM.set_phase2!","text":"set_phase2!(CH::AbstractChart, phase2::AbstractPhase2)\n\nSet the Phase 2 information of a control chart to simulate run lenghts.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.set_statistic!-Union{Tuple{C}, Tuple{STAT}, Tuple{C, STAT}} where {STAT<:SPM.AbstractStatistic, C<:SPM.AbstractChart}","page":"Control charts","title":"SPM.set_statistic!","text":"function set_statistic!(CH::AbstractChart, statistic::AbstractStatistic)\n\nSet the statistic of a control chart.\n\nReturns\n\nThe statistic that has been set.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.set_t!-Union{Tuple{C}, Tuple{C, Int64}} where C<:SPM.AbstractChart","page":"Control charts","title":"SPM.set_t!","text":"function set_t!(CH::AbstractChart, t)\n\nSet the current time point of a control chart.\n\nReturns\n\nThe time point of the statistic that has been set.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.set_value!-Union{Tuple{C}, Tuple{C, Any}} where C<:SPM.AbstractChart","page":"Control charts","title":"SPM.set_value!","text":"function set_value!(CH::AbstractChart, value)\n\nSet the value of the statistic of a control chart.\n\nReturns\n\nThe value of the statistic that has been set.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.shallow_copy_sim-Tuple{ControlChart}","page":"Control charts","title":"SPM.shallow_copy_sim","text":"shallow_copy_sim(CH::AbstractChart)\n\nCreate a shallow copy of a control chart, so that only the statistic and the control limit are copied. This is done to prevent copying eventual Phase 2 data multiple times and thus reduce computational effort when optimizing the control limit and the chart tuning parameters.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.update_chart!-Tuple{SPM.AbstractChart, Any}","page":"Control charts","title":"SPM.update_chart!","text":"update_chart!(CH::AbstractChart, x)\n\nUpdate the control chart inplace using a new observation x.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.update_chart-Tuple{SPM.AbstractChart, Any}","page":"Control charts","title":"SPM.update_chart","text":"update_chart(CH::AbstractChart, x)\n\nUpdate the control chart without modifying it using a new observation x.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.update_limit!-Union{Tuple{SPM.AbstractChart{S, L, N, P1}}, Tuple{P1}, Tuple{N}, Tuple{L}, Tuple{S}} where {S, L<:SPM.DynamicLimit, N, P1}","page":"Control charts","title":"SPM.update_limit!","text":"update_limit!(CH::AbstractChart, x)\n\nUpdate the dynamic control limit of a control chart inplace.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.run_path_sim-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.run_path_sim","text":"run_path_sim(CH::AbstractChart; maxiter)\nrun_path_sim(CH::MultipleControlChart; maxiter)\n\nSimulates a run length path for the control chart CH by sampling new data from its Phase II object.\n\nInputs\n\nCH::AbstractChart - A control chart.\nmaxiter::Real - The maximum value of the run length. Defaults to min(maxrl(CH), 10*get_nominal_value(CH))\n\nReturns\n\nA vector containing values of the control chart.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.run_sim-Tuple{SPM.AbstractChart, SPM.AbstractPhase2}","page":"Control charts","title":"SPM.run_sim","text":"run_sim(CH::AbstractChart, DGP::AbstractPhase2)\n\nSimulates a run length for the control chart CH by sampling new data from the provided data-generating process DGP.\n\nInputs\n\nCH - A control chart.\nDGP - An AbstractPhase2 object.\n\nReturns\n\nAn Int.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.run_sim-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.run_sim","text":"run_sim(CH::AbstractChart)\n\nSimulates a run length for the control chart CH by sampling new data from its Phase II object.\n\nInputs\n\nCH - A control chart.\n\nReturns\n\nAn Int.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.run_sim_oc-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.run_sim_oc","text":"run_sim_oc(CH::AbstractChart; shift = 0.0)\n\nSimulates a run length under location shift for the control chart CH by sampling new data from its Phase II object.\n\nInputs\n\nCH - A control chart.\nshift - A location shift.\n\nReturns\n\nAn Int.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.run_sim_sa-Tuple{SPM.AbstractChart}","page":"Control charts","title":"SPM.run_sim_sa","text":"run_sim_sa(CH::AbstractChart, maxiter::Real, delta::Real)\n\nSimulates a run length for the control chart CH by sampling new data from the Phase II object, to be used by the stochastic approximation algorithm implemented in the saCL! function.\n\nInputs\n\nCH - A control chart.\nmaxiter - The maximum value of the run length.\ndelta - A value controlling how much the control limit must be shifted for the gain estimation during the first stage.\n\nReturns\n\nA NamedTuple containing the simulated run length, rl, the simulated run length with control limit shifted by delta, rlPlus, and the simulated run length with control limit shifted by -delta, rlMinus.\n\n\n\n\n\n","category":"method"},{"location":"control_charts/#SPM.apply_chart!-Tuple{SPM.AbstractChart, AbstractVector}","page":"Control charts","title":"SPM.apply_chart!","text":"apply_chart(CH::AbstractChart, x::AbstractVecOrMat)\napply_chart!(CH::AbstractChart, x::AbstractVector)\napply_chart!(CH::AbstractChart, x::AbstractMatrix)\n\nApply a control chart to a data vector or data matrix x.\n\n\n\n\n\n","category":"method"},{"location":"statistics/#Monitoring-statistics","page":"Monitoring statistics","title":"Monitoring statistics","text":"","category":"section"},{"location":"statistics/","page":"Monitoring statistics","title":"Monitoring statistics","text":"Modules = [SPM]\nPages = [\"stats-interface.jl\", \"univariate.jl\", \"multivariate.jl\", \"residual.jl\", \"categorization.jl\", \"LLCUSUM.jl\", \"LLD.jl\", \"MOC.jl\", \"functional.jl\", \"NEWMA.jl\", \"adaptive-sampling.jl\", \"RSADA.jl\", \"TRAS.jl\"]","category":"page"},{"location":"statistics/#SPM.AEWMA","page":"Monitoring statistics","title":"SPM.AEWMA","text":"AEWMA(λ, k, value)\n\nAdaptive exponentially weighted moving average with design parameters λ, k, and initial value value.\n\nThe update mechanism for the statistic C_t based on a new observation x is given by\n\nC_t = (1-phi(e))cdot C_t-1 + phi(e) * x,\n\nwhere \\phi(e) is a forecast error function based on the Huber score function.\n\nArguments\n\nλ::Float64: The smoothing constant. Default is 0.1.\nk::Float64: The threshold value in the Huber score. Default is 3.0`.\nvalue::Float64: The initial value of the statistic. Default is 0.0.\n\nReferences\n\nCapizzi, G. & Masarotto, G. (2003). An Adaptive Exponentially Weighted Moving Average Control Chart. Technometrics, 45(3), 199-207.\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.CUSUM","page":"Monitoring statistics","title":"SPM.CUSUM","text":"CUSUM(k, value, upw::Bool)\n\nCUSUM statistic with design parameter k and initial value value.\n\nThe update mechanism based on a new observation x is given by:\n\nif upw == true, then C_t = max0 C_t-1 + x - k;\nif upw == false, then C_t = min0 C_t-1 + x + k.\n\nArguments\n\nk::Float64: The allowance constant of the CUSUM statistic. Defaults to 1.0.\nvalue::Float64: The current value of the cumulative sum. Defaults to 0.0.\nupw::Bool: A boolean indicating whether the CUSUM statistic is increasing or decreasing. Defaults to true.\n\nReferences\n\nPage, E. S. (1954). Continuous Inspection Schemes. Biometrika, 41(1/2), 100. https://doi.org/10.2307/2333009\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.EWMA","page":"Monitoring statistics","title":"SPM.EWMA","text":"EWMA(λ, value)\n\nExponentially weighted moving average with design parameter λ and initial value value.\n\nThe update mechanism for the statistic C_t based on a new observation x is given by\n\nC_t = (1-λ)cdot C_t-1 + λ cdot x.\n\nArguments\n\nλ::Float64: The smoothing constant. Defaults to 0.1.\nvalue::Float64: The initial value for the EWMA statistic. Defaults to 0.0.\n\nReferences\n\nRoberts, S. W. (1959). Control Chart Tests Based on Geometric Moving Averages. Technometrics, 1(3), 239-250. https://doi.org/10.1080/00401706.1959.10489860\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.OneSidedEWMA","page":"Monitoring statistics","title":"SPM.OneSidedEWMA","text":"OneSidedEWMA(λ, value, upw::Bool)\n\nOneSidedEWMA statistic with design parameter λ and initial value value.\n\nThe update mechanism based on a new observation x is given by:\n\nif upw == true, then C_t = max0 (1-λ)cdot C_t-1 + λcdot x;\nif upw == true, then C_t = min0 (1-λ)cdot C_t-1 + λcdot x;\n\nArguments\n\nλ::Float64: The smoothing constant. Default is 0.1.\nvalue::Float64: The current value of the statistic. Default is 0.0.\nupw::Bool: Whether the statistic should monitor increases (true) or decrease (falses) in the process mean. Default is true.\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.Shewhart","page":"Monitoring statistics","title":"SPM.Shewhart","text":"Shewhart(value)\n\nShewhart control chart.\n\nThe update mechanism of C_t based on a new observation x is given by\n\nC_t = x.\n\nReferences\n\nShewhart, W. A. (1931). Economic Control of Quality Of Manufactured Product. D. Van Nostrand Company.\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.WCUSUM","page":"Monitoring statistics","title":"SPM.WCUSUM","text":"WCUSUM <: AbstractStatistic\n\nA weighted cumulative sum statistic.\n\nArguments\n\nk::Float64: The allowance constant of the CUSUM used for calculating the WCUSUM statistic. Default is 1.0.\nλ::Float64: The smoothing constant for updating the estimate of the fault signature. Must be a value between 0 and 1. Default is 0.2.\nvalue::Float64: The initial value of the weighted cumulative sum statistic. Default is 0.0.\nQ::Float64: The residual value of the weighted cumulative sum. Default is 0.0.\nupw::Bool: Whether to monitor increases in the mean (true) or decreases (false). Default is true.\n\nReferences\n\nShu, L., Jiang, W., & Tsui, K.-L. (2008). A Weighted CUSUM Chart for Detecting Patterned Mean Shifts. Journal of Quality Technology, 40(2), 194-213. https://doi.org/10.1080/00224065.2008.11917725\n\nExamples\n\nstat = WCUSUM()\nget_design(stat)            # returns [1.0, 0.2]\nupdate_statistic(stat, 3.0) # returns 1.2\nstat.Q                      # returns 0.6\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.ALT","page":"Monitoring statistics","title":"SPM.ALT","text":"ALT{M}\n\nA Generalized Likelihood Ratio statistic for monitoring changes in the variance-covariance matrix.\n\nFields\n\nvalue::Float64: The value of the statistic, initialized to 0.0.\nΩ::M: The precision matrix of the in-control process.\ndetΣ::Float64: The determinant of the in-control process variance.\n\nReferences\n\nAlt, F. A. (1984). Multivariate quality control. In N. L. Johnson, S. Kotz, & C. R. Read (Eds.), The encyclopedia of statistical sciences (Vol. 6, pp. 110-122). Wiley.\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.AMCUSUM","page":"Monitoring statistics","title":"SPM.AMCUSUM","text":"AMCUSUM(λ, p; minshift = 0.1, shift = 0.0, Et = zeros(p), t = 0, stat = MCUSUM(k=0.1, p=p))\n\nAn Adaptive Multivariate Cumulative Sum (MCUSUM) statistic.\n\nArguments\n\nλ::Float64: The smoothing constant, such that 0.0 <= λ <= 1.0.\np::Int: The number of quality variables to monitor.\nminshift::Float64: The minimum shift value to be detected. Default is 0.1.\nshift::Float64: The current shift value. Default is 0.0.\nEt::Vector{Float64}: The vector Et of smoothed deviations from the zero mean. Has to be exactly equal to zeros(p)\nt::Int: The current value of time. Default is 0.\nstat::C: The underlying classical MCUSUM statistic. Default is MCUSUM(k=0.1, p=p).\n\nReferences\n\nDai, Y., Luo, Y., Li, Z., & Wang, Z. (2011). A new adaptive CUSUM control chart for detecting the multivariate process mean. Quality and Reliability Engineering International, 27(7), 877-884. https://doi.org/10.1002/qre.1177\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.DiagMEWMA","page":"Monitoring statistics","title":"SPM.DiagMEWMA","text":"DiagMEWMA(Λ, value)\n\nExponentially weighted moving average with diagonal smoothing matrix Λ and initial value value.\n\nThe update mechanism based on a new observation x is given by\n\nZ_t = (I-Λ)Z_t-1 + Λ x_t,\n\nand the chart value is defined as\n\nC_t = Z_t Λ^-1 Z_t.\n\nArguments\n\nΛ::Vector{Float64}: The vector of smoothing constants.\nvalue::Float64: Current value of the statistic (default = 0.0).\nz::Vector{Float64}: Vector of smoothed observations (Default: zeros(length(Λ))).\ninv_Σz::Matrix{Float64}: Inverse of the covariance matrix of the control variates.\n\nReferences\n\nLowry, C. A., Woodall, W. H., Champ, C. W., & Rigdon, S. E. (1992). A Multivariate Exponentially Weighted Moving Average Control Chart. Technometrics, 34(1), 46-53. https://doi.org/10.1080/00401706.1992.10485232\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.MAEWMA","page":"Monitoring statistics","title":"SPM.MAEWMA","text":"MAEWMA(λ, k, value, z::Vector{Float64})\n\nA Multivariate Adaptive Exponentially Weighted Moving Average.\n\nThe update mechanism based on a new observation x is given by\n\nZ_t = (I-Ω)*Z_t-1 + Ω * x_t,\n\nwhere Ω = ω(e)*I is an adaptive generalization of the classical MEWMA smoothing matrix. The chart value is defined as\n\nvalue_t = Z_t Z_t.\n\nArguments\n\nλ::Float64: The value of the EWMA smoothing parameter.\nk::Float64: The value of the parameter of the Huber score.\nvalue::Float64: The value of the statistic. (default: 0.0)\nz::Vector{Float64}: The vector of smoothed observations.\n\nReferences\n\nMahmoud, M. A., & Zahran, A. R. (2010). A Multivariate Adaptive Exponentially Weighted Moving Average Control Chart. Communications in Statistics - Theory and Methods, 39(4), 606-625. https://doi.org/10.1080/03610920902755813\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.MCUSUM","page":"Monitoring statistics","title":"SPM.MCUSUM","text":"MCUSUM(k, p, value = 0.0, St = zeros(p))\n\nA Multivariate Cumulative Sum (MCUSUM) statistic.\n\nArguments\n\nk::Float64: The value of the allowance parameter.\np::Int: The number of variables to be monitored. \nvalue::Float64: The initial value of the statistic. Default is 0.0.\nSt::Vector{Float64}: A vector representing the multivariate cumulative sum at the current time t.\n\nExamples\n\nstat = MCUSUM(0.25, 2, 0.0, [0.0, 0.0])\n\nReferences\n\nCrosier, R. B. (1988). Multivariate Generalizations of Cumulative Sum Quality-Control Schemes. Technometrics, 30(3), 291-303. https://doi.org/10.2307/1270083\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.MEWMC","page":"Monitoring statistics","title":"SPM.MEWMC","text":"MEWMC(λ, value)\n\nAn Exponentially Weighted Moving Covariance Matrix statistic with smoothing constant λ and initial value value.\n\nThe update mechanism for C_t based on a new observation x \\in \\mathbb{R}^p is given by\n\nZ_t = (1 - λ)Z_t-1 + λ cdot xx,\n\nand the chart value is defined as\n\nC_t = texttr(Z_t) - logZ_t - p.\n\nReferences\n\nHawkins, D. M., & Maboudou-Tchao, E. M. (2008). Multivariate Exponentially Weighted Moving Covariance Matrix. Technometrics, 50(2), 155-166.\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.MEWMS","page":"Monitoring statistics","title":"SPM.MEWMS","text":"MEWMS(λ, value)\n\nExponentially weighted moving covariance matrix with smoothing constant λ.\n\nThe update mechanism based on a new observation x \\in \\mathbb{R}^p is given by\n\nZ_t = (1 - λ)*Z_t-1 + λ cdot xx,\n\nand the chart value is defined as\n\n``valuet = \\text{tr}(Zt).\n\nReferences\n\nHuwang, L., Yeh, A. B., & Wu, C.-W. (2007). Monitoring Multivariate Process Variability for Individual Observations. Journal of Quality Technology, 39(3), 258-278. https://doi.org/10.1080/00224065.2007.11917692\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.MShewhart","page":"Monitoring statistics","title":"SPM.MShewhart","text":"MShewhart(value)\n\nShewhart control chart for monitoring multivariate observations with initial value value.\n\nThe update mechanism of C_t based on a new observation x is given by\n\nC_t = xx.\n\nReferences\n\nShewhart, W. A. (1931). Economic Control of Quality Of Manufactured Product. D. Van Nostrand Company.\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.RiskAdjustedCUSUM","page":"Monitoring statistics","title":"SPM.RiskAdjustedCUSUM","text":"RiskAdjustedCUSUM{G} <: AbstractStatistic\n\nRisk-adjusted CUSUM monitoring statistic.\n\nArguments\n\nΔ::Float64: Shift in the linear predictor of the logistic regression model to be detected.\nmodel::G: Logistic regression model used for prediction. Must have a predict(model, x) function.\nresponse::Symbol: Name of the response variable in the DataFrame.\nvalue::Float64: Initial value of the statistic. Defaults to 0.0.\n\nReferences\n\nSteiner, S. H., Cook, R. J., Farewell, V. T., Treasure, T. (2000). Monitoring surgical performance using risk-adjusted cumulative sum charts. Biostatistics, 1(4), 441-452. https://doi.org/10.1093/biostatistics/1.4.441 ```\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.LocationScaleStatistic","page":"Monitoring statistics","title":"SPM.LocationScaleStatistic","text":"LocationScaleStatistic{S, M, P}\n\nA mutable struct representing a statistic applied to a location-scale family.\n\nFields\n\nstat::S: The statistic.\nμ::M: The location parameter.\nΩ::P: The inverse square root of the variance.\n\nExamples\n\nSTAT = EWMA(λ = 0.2)\nRSTAT = LocationScaleStatistic(STAT, 1.0, 2.5)\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.categorize_data-Tuple{AbstractVector, Vector{Vector{Float64}}}","page":"Monitoring statistics","title":"SPM.categorize_data","text":"categorize_data(x::AbstractVector, qtls::Vector{Vector{Float64}})\ncategorize_data(x::AbstractMatrix, qtls::Vector{Vector{Float64}})\n\nCategorize continuous data using the medians of the continuous variables.\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.compose-Tuple{Symbol, Tuple}","page":"Monitoring statistics","title":"SPM.compose","text":"compose(lhs::Symbol, rhs::Tuple)\ncompose(lhs::Symbol, rhs::Term)\ncompose(lhs::Symbol, rhs::ConstantTerm)\n\nCompose a response variable lhs with a tuple or vector of predictors rhs terms.\n\nArguments\n\nlhs::Symbol: The left-hand side of the equation.\nrhs::Tuple: The right-hand side of the equation.\n\nReturns\n\nThe composed equation.\n\nIf rhs is empty, the function returns lhs composed with an intercept. Otherwise, the function returns lhs composed with the terms in rhs.\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.get_removable_terms-Tuple{Any}","page":"Monitoring statistics","title":"SPM.get_removable_terms","text":"get_removable_terms(rhs)\n\nGiven an iterable collection of terms rhs, this function returns the indices of the terms in rhs that can be removed in a backward elimination step.\n\nArguments\n\nrhs: An iterable collection of terms in the equation.\n\nReturns\n\nAn array of indices of the terms in rhs that have the maximum order.\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.kronecker_matrix-Tuple{AbstractVector}","page":"Monitoring statistics","title":"SPM.kronecker_matrix","text":"kronecker_matrix(qtls::AbstractVector)\n\nCompute the matrix given by the Kronecker vectors according to Equation (6) of Wang et Al. (2017). This matrix is used to compute the approximate GLRT statistic to test the null hypothesis that the main effects and the second order interactions of a log-linear model are stable.\n\nReferences\n\nWang, J., Li, J., & Su, Q. (2017). Multivariate Ordinal Categorical Process Control Based on Log-Linear Modeling. Journal of Quality Technology, 49(2), 108-122. https://doi.org/10.1080/00224065.2017.11917983\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.quantile_range-Tuple{Any, Any, Any}","page":"Monitoring statistics","title":"SPM.quantile_range","text":"quantile_range(lower, upper, m)\n\nGet the set of quantiles needed to divide the data in m classes.\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.LLCUSUM","page":"Monitoring statistics","title":"SPM.LLCUSUM","text":"LLCUSUM(x::AbstractMatrix, k::Real; ncuts::AbstractVector = [2 for _ in eachcol(x)])\n\nA distibution-free Log-Linear CUSUM monitoring statistic based on data categorization.\n\nFields\n\nk::Float64: The allowance constant of the CUSUM statistic.\nvalue::Float64: The initial value of the statistic (default: 0.0).\nSobs::Vector{Float64}: The vector of cumulative observed categories.\nSexp::Vector{Float64}: The vector of expected observed categories.\nqtls::Vector{Vector{Float64}}: A vector of quantiles used for data categorization.\nf0::Vector{Float64}: The vector of IC cell probabilities, estimated using a loglinear model.\ntable::Matrix{Float64}: The matrix of cell combinations.\n\nReferences\n\nQiu, P. (2008). Distribution-free multivariate process control based on log-linear modeling. IIE Transactions, 40(7), 664-677. https://doi.org/10.1080/07408170701744843\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.categorical_to_index-Tuple{AbstractVector, AbstractMatrix}","page":"Monitoring statistics","title":"SPM.categorical_to_index","text":"categorical_to_index(g::AbstractVector, table::AbstractMatrix)\n\nConverts a categorized variable g to its corresponding index in a table.\n\nArguments\n\ng::AbstractVector: The categorical variable to convert.\ntable::AbstractMatrix: The table containing all the possible categories.\n\nReturns\n\nInt: The index of the category in the table.\n\nRaises\n\nErrorException if the index is not found\n\nExample\n\nx = randn(500, 3)\ndf, table, qtls = create_table(x, [2 for _ in eachcol(x)])\nxnew = randn(3)\ng = categorize_data(xnew, qtls)\nidx = categorical_to_index(g, table)\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.estimate_loglinear_model_probabilities-Tuple{Any, Any}","page":"Monitoring statistics","title":"SPM.estimate_loglinear_model_probabilities","text":"estimate_ordinal_model_probabilities(df, table)\n\nEstimates the probabilities of an ordinal loglinear model based on the observed cell counts.\n\nArguments\n\ndf::DataFrame: The data frame containing the predictor variables.\ntable::AbstractMatrix: The matrix of predictor values for which probabilities are to be estimated.\n\nReturns\n\nprob::Vector{Float64}: A vector of estimated probabilities.\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.LLD","page":"Monitoring statistics","title":"SPM.LLD","text":"LLD(x::AbstractMatrix, l::Real; ncuts::AbstractVector = [3 for _ in eachcol(x)], N = 1)\n\nA Log-Linear Directional monitoring statistic based on data categorization.\n\nFields\n\nl::Float64: The exponentially weighted smoothing constant of the statistic.\nvalue::Float64: The initial value of the statistic (default: 0.0).\nqtls::Vector{Vector{Float64}}: A vector of quantiles used for data categorization.\nf0::Vector{Float64}: The vector of IC cell probabilities, estimated using a loglinear model.\ntable::Matrix{Float64}: The matrix of cell combinations.\nSigma::Matrix{Float64}: The covariance matrix of the cell counts.\ndirections::Matrix{Float64}: The matrix of directions to be used in the hypohesis test (see Equation (6) of [Li, 2012]). This is calculated according to the procedure described in Equations (5) and (6) of [Wang, 2017].\nN::Int: The number of observations at each time point (default: 1)\nz_k::Vector{Float64}: The current vector of smoothed values.\n\nReferences\n\nLi, J., Tsung, F., & Zou, C. (2012). Directional Control Schemes for Multivariate Categorical Processes. Journal of Quality Technology, 44(2), 136â€“154. https://doi.org/10.1080/00224065.2012.11917889\n\nWang, J., Li, J., & Su, Q. (2017). Multivariate Ordinal Categorical Process Control Based on Log-Linear Modeling. Journal of Quality Technology, 49(2), 108-122. https://doi.org/10.1080/00224065.2017.11917983\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.MOC","page":"Monitoring statistics","title":"SPM.MOC","text":"MOC(x::AbstractMatrix, l::Real; ncuts::AbstractVector = [3 for _ in eachcol(x)], N = 1)\n\nA Multivariate Ordinal Categorical monitoring statistic based on data categorization.\n\nFields\n\nl::Float64: The exponentially weighted smoothing constant of the statistic.\nvalue::Float64: The initial value of the statistic (default: 0.0).\nqtls::Vector{Vector{Float64}}: A vector of quantiles used for data categorization.\nf0::Vector{Float64}: The vector of IC cell probabilities, estimated using a loglinear model.\ntable::Matrix{Float64}: The matrix of cell combinations.\ninv_VCOV::Matrix{Float64}: The matrix containing the inverse covariance to be used in the running statistic.\nN::Int: The number of observations at each time point (default: 1)\nz_k::Vector{Float64}: The current vector of smoothed values.\n\nReferences\n\nWang, J., Li, J., & Su, Q. (2017). Multivariate Ordinal Categorical Process Control Based on Log-Linear Modeling. Journal of Quality Technology, 49(2), 108-122. https://doi.org/10.1080/00224065.2017.11917983\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.estimate_ordinal_model_probabilities-Tuple{DataFrames.DataFrame, Any}","page":"Monitoring statistics","title":"SPM.estimate_ordinal_model_probabilities","text":"estimate_ordinal_model_probabilities(df, table)\n\nEstimates the probabilities of an ordinal loglinear model based on the observed cell counts.\n\nArguments\n\ndf::DataFrame: The data frame containing the predictor variables.\ntable::AbstractMatrix: The matrix of predictor values for which probabilities are to be estimated.\n\nReturns\n\nprob::Vector{Float64}: A vector of estimated probabilities.\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.NEWMA","page":"Monitoring statistics","title":"SPM.NEWMA","text":"NEWMA\n\nA Nonparametric Exponentially Weighted Moving Average statistic for monitoring profiles.\n\nFields\n\nλ::Float64: The EWMA smoothing constant. Must be between 0 and 1.\nvalue::Float64: The current value of the NEWMA statistic.\nσ::Float64: The standard deviation of the error term.\ncdf_σ::E: A function that computes the (estimated) cdf of the error term σ with signature cdf_σ(x::Real).\ng::F: The estimated regression function object. Must have a method of signature predict(g::F, x::AbstractVector).\nEj::Vector{Float64}: The current smoothed observations.\n\nReferences\n\nZou, C., Tsung, F., & Wang, Z. (2008). Monitoring Profiles Based on Nonparametric Regression Methods. Technometrics, 50(4), 512-526. https://doi.org/10.1198/004017008000000433\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.NEWMA-Tuple{Float64, Any, Array{FunctionalObservation{A, B}, 1} where {A, B}}","page":"Monitoring statistics","title":"SPM.NEWMA","text":"NEWMA(λ::Float64, g::F, dat::FunctionalData)\n\nConstruct a NEWMA control chart by calculating the standard errors for a functional regression model.\n\nArguments\n\nλ::Float64: The EWMA smoothing constant. Must be between 0 and 1.\ng::F: The estimated regression function object. Must have a method of signature predict(g::F, x::AbstractVector).\ndat::FunctionalData: A FunctionalData object containing observations of the regression curves.\nEj::Vector{Float64}: The current smoothed observations.\n\nReturns\n\nThe constructed NEWMA control chart.\n\nExamples\n\nusing Loess\nxs = 10 .* rand(100)\nys = sin.(xs) .+ rand(100)\ng = loess(xs, ys)\ndat = FunctionalData(xs, ys)\nNEWMA(0.2, g, dat)\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.AbstractSampling","page":"Monitoring statistics","title":"SPM.AbstractSampling","text":"AbstractSampling\n\nAbstract type representing a generic sampling method for partially-observed data.\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.ThompsonSampling","page":"Monitoring statistics","title":"SPM.ThompsonSampling","text":"ThompsonSampling <: AbstractSampling\n\nType representing the Thompson Sampling method.\n\nFields\n\nβ::Float64: A parameter regulating the concentration of the Dirichlet distribution for Thompson sampling.\n\nExamples\n\nts = ThompsonSampling(2.0)\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.TopQ","page":"Monitoring statistics","title":"SPM.TopQ","text":"TopQ <: AbstractSampling\n\nType representing the TopQ sampling method. New data is generating by taking the q local statistics with highest value. \n\nReferences\n\nMei, Y. (2011). Quickest detection in censoring sensor networks. 2011 IEEE International Symposium on Information Theory Proceedings, 2148-2152. https://doi.org/10.1109/ISIT.2011.6034390\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.new_layout-Tuple{AbstractSampling, Any, Int64}","page":"Monitoring statistics","title":"SPM.new_layout","text":"new_layout(sampling::AbstractSampling, local_statistics) -> layout\n\nAbstract function that creates a new layout based on the given sampling method and local statistics.\n\nArguments\n\nsampler::AbstractSampling: An instance of an object subtype of AbstractSampling.\nlocal_statistics: Array of local statistics used for generating the layout.\nq::Int: The number of items to include in the layout.\n\nReturns\n\nlayout: The generated layout to observe at the next iteration.\n\nExamples\n\n# Create an instance of ThompsonSampling\nts = ThompsonSampling(2.0)\n\n# Generate a layout using ThompsonSampling\nstats = [1, 2, 3, 4]\nlayout = new_layout(ts, stats, 2)\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.RSADA","page":"Monitoring statistics","title":"SPM.RSADA","text":"RSADA{D,S}\n\nA R-SADA monitoring statistic, whcih is used for monitoring the mean of partially-observed independent data streams. The monitoring statistic iteratively samples arms (data streams) and updates a set of local statistics based on the observed values of the data streams. The RSADA algorithm uses the local statistics to make decisions on which arms to sample at each iteration.\n\nFields\n\nk: The allowance constant of the CUSUM Control chart. Default value is 0.1.\nmu_min: The minimum value of the mean shift to detect. Default value is 0.2.\np::Int: The number of independent data streams. Default value is 1.\nq::Int: The number of data streams that are observable at each iteration. Default value is 1.\ndist::Distribution: The distribution of the data streams. Default value is Normal(0,1).\nvalue: The current value of the monitoring statistic. Default value is 0.0.\neta: The vector of augmented variables. Initialized to be a vector of zeros for each data stream.\nobs::Vector{Int}: The indices of the data streams to sample. Default value is an array of q random integers between 1 and p.\nS1::Vector{F}: The sum of the rewards for each arm.\nS2::Vector{F}: The sum of the squared rewards for each arm.\n\nReferences\n\nXian, X., Zhang, C., Bonk, S., & Liu, K. (2019). Online monitoring of big data streams: A rank-based sampling algorithm by data augmentation. Journal of Quality Technology, 53(2), 135-153. https://doi.org/10.1080/00224065.2019.1681924\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.augmented_vector!-NTuple{5, Any}","page":"Monitoring statistics","title":"SPM.augmented_vector!","text":"augmented_vector(y, obs, mu, dist)\n\nCompute the augmented vector eta (Equation 10 of [Xian et Al., 2019]) based on the given parameters.\n\nArguments\n\ny: The input vector.\nobs: The indices of the observed elements in y.\nmu: The mean parameter.\ndist: The IC distribution of the individual data streams.\n\nReturns\n\neta: The computed augmented vector.\n\nReferences\n\nXian, X., Zhang, C., Bonk, S., & Liu, K. (2019). Online monitoring of big data streams: A rank-based sampling algorithm by data augmentation. Journal of Quality Technology, 53(2), 135-153. https://doi.org/10.1080/00224065.2019.1681924\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.update_sampling!-Tuple{RSADA}","page":"Monitoring statistics","title":"SPM.update_sampling!","text":"update_sampling!(STAT::RSADA)\n\nUpdate the monitored data streams of the RSADA monitoring statistic STAT by selecting the top-q values of the local monitoring statistics in STAT.S1.\n\nArguments\n\nSTAT: The RSADA object to update.\n\nReturns\n\nSTAT.obs: The selected indices of the top STAT.q values of STAT.S1.\n\n\n\n\n\n","category":"method"},{"location":"statistics/#SPM.TRAS","page":"Monitoring statistics","title":"SPM.TRAS","text":"TRAS{F,D}\n\nFields\n\nA Top-r-based Adaptive Sampling monitoring statistic for monitoring multiple data streams with partial observations.\n\nFields\n\nk::Float64: The allowance constant for the CUSUM statistic. Defaults to 0.1.\nmu_min::Float64: The minimum shift to be detected. Defaults to 1.0.\nvalue::Float64: The current value of the monitoring statistic. Defaults to 0.0.\nΔ::Float64: The compensation coefficient for non-observed variables.\nr::Int: The number of largest variables to sum.\nq::Int: The total number of observable variables.\np::Int: The total number of variables.\nW::Vector{Float64}: The vector of local monitoring statistics. Defaults to a vector of zeros.\nW1::Vector{Float64}: The vector used to store the local monitoring statistics to detect increases in the mean. Defaults to a vector of zeros.\nW2::Vector{Float64}: The vector used to store the local monitoring statistics to detect decreases in the mean. Defaults to a vector of zeros.\nobs::Vector{Int}: The selected indices of the top q values of local monitoring statistics. Defaults to a random sample of size q from the range 1:p.\nsampler::S: The sampling strategy used to select the next set of obs indices. Defaults to ThompsonSampling().\n\nReferences\n\nLiu, K., Mei, Y., & Shi, J. (2015). An Adaptive Sampling Strategy for Online High-Dimensional Process Monitoring. Technometrics, 57(3), 305-319. https://doi.org/10.1080/00401706.2014.947005\n\n\n\n\n\n","category":"type"},{"location":"statistics/#SPM.update_sampling!-Tuple{TRAS}","page":"Monitoring statistics","title":"SPM.update_sampling!","text":"update_sampling!(STAT::TRAS)\n\nUpdate the monitored data streams of the TRAS monitoring statistic STAT using its associated AbstractSampler object.\n\nArguments\n\nSTAT: The TRAS object to update.\n\nReturns\n\nSTAT.obs: The selected indices of the top STAT.q values of STAT.S1.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = SPM","category":"page"},{"location":"#SPM","page":"Introduction","title":"SPM","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation for SPM, a package for Statistical Process Monitoring.","category":"page"},{"location":"#Package-features","page":"Introduction","title":"Package features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Control charts\nUnivariate Shewhart, EWMA, AEWMA, CUSUM, adaptive CUSUM control charts.\nMultivariate Shewhart, MEWMA, MAEWMA, MCUSUM, AMCUSUM control charts.\nControl charts for monitoring the variance-covariance matrix.\nControl charts based on data categorization for monitoring the process mean.\nControl charts for partially-observed data streams.\nControl charts for profile monitoring.\nSupport for multi-chart monitoring schemes.\nControl limits\nClassical one-sided and two-sided fixed control limits-\nDeterministic time-varying control limits.\nDynamic control limits based on bootstrap with constat false-alarm rate.\nControl limit design\nClassical and improved bisection methods.\nStochastic approximation algorithms.\nSupport for in-control ARL and in-control run length quantiles.\nSupport for multi-chart control limit design.\nHyperparameter tuning\nOptimization of control chart parameters for user-defined out-of-control scenarios.\nAlgorithms based on grid search and nonlinear optimizers.\nExtensibility to user-defined monitoring statistics","category":"page"},{"location":"monitoring_autoregressive/#Monitoring-residuals-of-an-autoregressive-process","page":"Monitoring residuals of an autoregressive process","title":"Monitoring residuals of an autoregressive process","text":"","category":"section"}]
}
